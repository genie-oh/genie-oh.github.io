{"pages":[{"title":"About Me","text":"/* Variables */ /* Fonts */ /* Styling */ .custom-timeline { margin: 4em auto; position: relative; max-width: 46em; } .custom-timeline:before { background-color: black; content: ''; margin-left: -3px; position: absolute; top: 0; left: 32px; width: 2px; height: 100%; } .custom-timeline-event { position: relative; } .custom-timeline-event:hover .custom-timeline-event-icon { -moz-transform: rotate(-45deg); -ms-transform: rotate(-45deg); -webkit-transform: rotate(-45deg); transform: rotate(-45deg); background-color: #a83279; } .custom-timeline-event:hover .custom-timeline-event-thumbnail { -moz-box-shadow: inset 40em 0 0 0 #a83279; -webkit-box-shadow: inset 40em 0 0 0 #a83279; box-shadow: inset 40em 0 0 0 #a83279; } .custom-timeline-event-copy { padding: 2em; padding-bottom: 0; padding-left: 0; position: relative; top: -1.875em; left: 4em; width: 80%; } .custom-timeline-event-copy h3 { font-size: 1.75em; } .custom-timeline-event-copy h4 { font-size: 1.2em; margin-bottom: 1.2em; } .custom-timeline-event-copy strong { font-weight: 700; } .custom-timeline-event-copy p:not(.custom-timeline-event-thumbnail) { padding-bottom: 1.2em; } .custom-timeline-event-icon { -moz-transition: -moz-transform 0.2s ease-in; -o-transition: -o-transform 0.2s ease-in; -webkit-transition: -webkit-transform 0.2s ease-in; transition: transform 0.2s ease-in; -moz-transform: rotate(45deg); -ms-transform: rotate(45deg); -webkit-transform: rotate(45deg); transform: rotate(45deg); background-color: black; outline: 10px solid white; display: block; margin: 0.5em 0.5em 0.5em -0.5em; position: absolute; top: 0; left: 2em; width: 1em; height: 1em; } .custom-timeline-event-thumbnail { -moz-transition: box-shadow 0.5s ease-in 0.1s; -o-transition: box-shadow 0.5s ease-in 0.1s; -webkit-transition: box-shadow 0.5s ease-in; -webkit-transition-delay: 0.1s; transition: box-shadow 0.5s ease-in 0.1s; color: white; font-size: 0.75em; background-color: black; -moz-box-shadow: inset 0 0 0 0em #ef795a; -webkit-box-shadow: inset 0 0 0 0em #ef795a; box-shadow: inset 0 0 0 0em #ef795a; display: inline-block; margin-bottom: 1.2em; width: 161px; margin-left: -32px; text-align: left; padding-left: 32px; } ul.custom-timeline { list-style: none; margin: 0; margin-bottom: 50px; } ul.custom-timeline .custom-timeline-event-copy div { margin-bottom: 1em; padding-bottom: 1.2em; } ul.custom-timeline h1 { border: 0 !important; padding: 0 !important; margin: 0 0 10px 0 !important; } Profile NickName genie-oh FullName Hyunjin. Oh Job Semi-Fullstack Web Engineer Lived in 2018 - now : Japan(Tokyo) 1986 - 2017 : Korea. rep(Seoul, Busan) Communication Languages Japanese : Business & Semi Native Level Korean : Naitve English : some Read & Write Contacts Twitter : @dev-genie_oh Skills Main Engineering Skill Web Service Application Side Architecture Design Know-how about Payment Gateway Service Service Requirement Definition Data Modeling, UseCase Modeling Develop Back-end Application (PHP, PHP Framework) Do documentation of System Specification Sub Engineering Skill Develop Front-end Application (Typescript, React, Jquery, Vanilla Javascript) Markup Front-end (HTML, CSS, LESS, Bootstrap) Operation Skill on Linux. Strong & Weak Strong Point (I Can provice talent) Application Side Architecture Design & Modeling Payment System Know-How Requirement Definition Documentation Develop Back-end Application Weak Point (is Studying...) Infrastructer Skill (AWS, Docker, Automation Deploy...) Human Resource Management on Projects Modern Programming Skills Career 2018.01 - now OZ-VISION. inc Providing Point Income Services & Others(on Japan) Hapitas Comic Service Main Engineer (New Startup Business) Service Application Architecture Design(Requirement Definition, Database Modeling, Sitemap, Wireframe, Functional Specification) Lead development of core features (Payment feature, Contents access control) Hapitas Service Engineer Develop & Operate something on Hapitas Service(PC, SP, APP) Make Lecture programs for newcomer. (step by step small project) 2013.01 - 2017.01 Danal. inc providing Payment Gateway Services(on Korea. rep) Payment Gateway Back-end Engneer Architecture Design of Payment Gateway System Do Documentation for Payment Gateway System Develop & Operate Payment Gateway Transaction Server Patent Lead do patent about end-point-encryption number input interface module on a website Lead develop & integration it to the real service system Past - 2012.12 Dongseo University(on Korea. rep / for 4 years) specialize in Information Network of Computer Science","link":"/about/me/index.html"}],"posts":[{"title":"ブログ開設しました！","text":"はじめまして！韓国出身で、現在は日本でウェブエンジニアとして努めさせて頂いている呉(オー)と申します。 プロフィールは以下のページに記載しておりますので、興味のお持ちの方はぜひご覧頂けると嬉しいです。 ● LINK : AboutMe Git Page、Hexo, Icarusテーマを利用して、ブログを開設してみました。 ウェブ・エンジニアリング全般から、アプリケーション設計、システム・エンジニアリング、サービス制作など、いろんな話を残していけばいいなとおもています。 まだ、いろいろ学んでいる身ではありますが、楽しくやって行きたいと思っています。何卒、宜しくお願い申し上げます。","link":"/2020/07/06/%E3%83%96%E3%83%AD%E3%82%B0%E9%96%8B%E8%A8%AD%E3%81%97%E3%81%BE%E3%81%97%E3%81%9F%EF%BC%81/"},{"title":"Docker。自分がよく使うコマンドをaliasに設定「説明付き」","text":"はじめに私が思うよく使うDockerコマンドは、bash_profileや、bash_rcでaliasに設定して使っています。 自分の誹謗録ようなものですが、興味のある方はお試しください。そして、もし有用なaliasを使っているならぜひ共有頂けると嬉しいです。 自分も勉強目的で書いているので、間違った情報があるかもしれません。そこはご指摘頂けるとありがたいです。 alias設定内容~/.bash_profile以下の構文を追加 123if [ -f ~/.myalias ]; then source ~/.myaliasfi ~/.myalias● gisthttps://gist.github.com/genie-oh/d73a224e7cb3cffab2868182eb79ccad ※説明al-dockDocker関連aliasのリストを表示 12345678910111213141516171819202122$ al al-dockexecute : cat ~/.myalias | grep dock | sed \"s/=/ \\t\\= /\" # dockeralias al-dock = 'cat ~/.myalias | grep dock | sed \"s/=/ \\t\\= /\"'alias dock = 'docker'alias docki = 'docker images'alias dockps = 'docker ps -a'alias dockrrm = 'docker run --rm'alias dockeit = 'docker exec -it'alias dockrm = 'docker rm -f'alias dockrmi = 'docker rmi -f'alias dockrma = 'docker rm -f $(docker ps -aq)'alias dockrmia = 'docker rmi -f $(docker images -aq)'alias dockins = 'docker inspect'alias dockip = 'docker inspect --format=\"{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}\"'alias docklogs = 'dock logs --tail 50 --follow --timestamps'alias dockc = 'docker-compose'alias dockcb = 'docker-compose build'alias dockcu = 'docker-compose up -d'alias dockcd = 'docker-compose down'alias dockccl = 'grep container_name docker-compose.yml' dockc, dockcb, dockcu, dockcddocker-compose関連docker-composeのbuild,up,down 1234alias dockc = 'docker-compose'alias dockcb = 'docker-compose build'alias dockcd = 'docker-compose down'alias dockcu = 'docker-compose up -d' dockccldocker-compose.yml内のコンテナーネームのリストを出力 1alias dockccl = 'grep container_name docker-compose.yml' 123456$ al dockcclexecute : grep container_name docker-compose.yml container_name: lamp-web container_name: lamp-php...省略 dockidocker imageのリストを出力 1alias docki = 'docker images' 1234567$ al dockiexecute : docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEcentos 7 b5b4d78bc90c 8 weeks ago 203MBdocker-lamp-test_php latest e6d67d8f48cf 17 minutes ago 666MB...省略 dockpsdockerのコンテナーリストと実行状態を表示 1alias dockps = 'docker ps -a' 123456$ al dockpsexecute : docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES6116324251dd docker-lamp-test_php \"docker-php-entrypoi…\" 17 minutes ago Up 17 minutes 0.0.0.0:32769-&gt;9000/tcp lamp-php...省略 dockeit実行中のコンテナーで、interactive&amp;ttyモードでコマンド実行docker exec –interective –tty 1alias dockeit = 'docker exec -it' 12345$ al dockeit lamp-php bashexecute : docker exec -it lamp-php bashroot@37bcdbd02f92:/var/www/html# lsconfig gulpfile.js home_root home_sub nodeapp dockrrmコンテナーでコマンドを実行後、即時にコンテナーを終了するコンテナー作成▶コマンド実行▶コンテナー終了 1alias dockrrm = 'docker run --rm' 12345$ al dockrrm composer php -vexecute : docker run --rm composer php -vPHP 7.4.7 (cli) (built: Jun 11 2020 18:58:32) ( NTS )...省略 dockinsコンテナーの状態を確認 1alias dockins = 'docker inspect' 12345678$ al dockins lamp-phpexecute : docker inspect lamp-php[ { \"Id\": \"6116324251ddffc8090cc605d391f89a951aeb46d32636dd62476a225a894c51\", \"Created\": \"2020-07-01T13:30:27.11145Z\",...省略 dockipコンテナーの状態で、IPだけを取得 1alias dockip = 'docker inspect --format=\"{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}\"' 1234$ al dockip lamp-phpexecute : docker inspect --format=\"{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}\" lamp-php172.30.0.5 docklogsコンテナーのログを確認 1alias docklogs = 'dock logs --tail 50 --follow --timestamps' 12345$ al docklogs lamp-phpexecute : docker logs --tail 50 --follow --timestamps lamp-php2020-07-01T13:30:28.338589500Z [01-Jul-2020 22:30:28] NOTICE: fpm is running, pid 12020-07-01T13:30:28.340324600Z [01-Jul-2020 22:30:28] NOTICE: ready to handle connections dockrm, dockrmi特定のコンテナー、またはイメージを削除 12alias dockrm = 'docker rm -f'alias dockrmi = 'docker rmi -f' dockrma, dockrmiaすべてのコンテナー、またはイメージを削除 12alias dockrma = 'docker rm -f $(docker ps -aq)'alias dockrmia = 'docker rmi -f $(docker images -aq)'","link":"/2020/07/09/Docker%E3%80%82%E8%87%AA%E5%88%86%E3%81%8C%E3%82%88%E3%81%8F%E4%BD%BF%E3%81%86%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89%E3%82%92alias%E3%81%AB%E8%A8%AD%E5%AE%9A%E3%80%8C%E8%AA%AC%E6%98%8E%E4%BB%98%E3%81%8D%E3%80%8D/"},{"title":"Git Pages &amp; Hexoで手軽な無料Blogを作る","text":"1. はじめにGit Pagesとhexoという静的ページジェネレーターで、設置型ブログを無料で作ることができます。 1) Git Pages &amp; 静的ページジェネレーターを使ったブログのメリット サーバーいらず、DBいらず、サーバーサイド開発いらず、それなりにちゃんとした自分のブログを持てる お金がかからず、無制限トラフィックで、ウェブページを提供できる カスタマイズが自由で、個性のあるブログを作れる(テーマ開発など) ブログの記事をファイルで作成するので、コード管理ができる 2) Git Pagesとは？https://pages.github.com Githubで提供している、無料ウェブページホスティングサービスです。html, css, jsなどの静的コンテンツのみですが、無料でウェブページをサービスできます。 3) Hexoとは？https://hexo.io node基盤の「静的ページゼネレーター」の一つです。サーバーの動的処理なしに、リッチなウェブページやブログなどを生成してくれます。 4) 完成イメージ以下のように、ブログを作り、一つの記事をポストします。 では、早速作って見ましょう。 2. Blogを作る手順1) Hello World on Git PagesGit Pages Manualhttps://pages.github.com/ ① ホスティング用のレポジトリ生成{userid}.github.ioの名前でパブリック・レポジトリを生成します。上記の規則で作成したレポジトリは、自動的にGit Pagesの機能により、ウェブホスティングされます。 ② index.htmlをプッシュindex.htmlを作り、{userid}.github.ioレポジトリにをプッシューします。 123456789git clone https://github.com/{username}/{username}.github.io.gitcd {username}.github.iotouch index.htmlgit add index.htmlgit commit -m \"first commit\"echo \"Hello World\" &gt; index.htmlgit add index.htmlgit commit -m \"second commit\"git push origin master ③ git page build結果確認Github Actionを見ると、上げたindex.htmlがGit Pagesとしてビルドされていることを確認できます。 ④ 確認https://{username}.github.ioにアクセスすると、Hello Worldが確認できます。これで、ウェブページのホスティングの準備ができました。 2) hexo 設置 &amp; 設定 (静的ページゼネレーター)Hexoを使うためには、まずnode&amp;npmのインストールが必要です。もし、インストールが必要な方は、以下の公式ページをご参考ください。 ● nodejs with npmhttps://nodejs.org/ja/ Hexoの公式 docs &amp; Installationはこちらで参考できます。https://hexo.io/docs/ ① インストールhexoをインストールします。 1234npm install -g hexo-clihexo init blogcd blognpm install ② hexo-deployer-git plugin インストールOne Commandで、githubにデプロイするためのプラグインを予めインストールします。プラグインの詳細はこちらで確認できます。 https://github.com/hexojs/hexo-deployer-git 1npm install hexo-deployer-git --save ③ _config.yml 設定基本的なconfig設定を行います。 url Git PagesのURLを設定します。 new_post_name Post記事の生成時のファイル名を設定します。ここは必須に変える必要は無いですが、datetimeをつけたほうが管理しやすいと思います。 Deployment hexo-deployer-gitのpluginをインストールしたので、gitのデプロイ設定ができます。 messageは、設定しないと基本メッセージとして、Site updated: YYYY-MM-DD HH:mm:ssの形式でコミットメッセージが残ります。 123456789101112131415diff --git a/_config.yml b/_config.yml-url: http://yoursite.com+url: https://{username}.github.io/-new_post_name: :title.md # File name of new posts+new_post_name: :year_:month_:day_:title.md # File name of new posts # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy:- type: ''+ type: git+ repo: https://github.com/{username}/{username}.github.io+ branch: master これで、ブログの基本設定は終わりました。 3) 記事作成記事を作成します。 ① 記事のソース・マークダウン生成hexo new {title}で、新しい記事が生成できます。すると、以下のように新しいファイルが生成されます。 12$ hexo new \"first post\"INFO Created: D:\\Develop\\_GitPages\\blog\\source\\_posts\\2020_07_04_first-post.md ② マークダウン・ファイル編集生成された記事のマークダウンを開き、試しに以下のように変更します。 123456789101112131415161718192021222324252627282930313233343536373839404142434445---title: first postdate: 2020-07-04 18:52:00tags: - hello worldcategory: - hello worldexcerpt: welcome to my blog---Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).## Quick Start### Create a new post``` bash$ hexo new \"My New Post\"```More info: [Writing](https://hexo.io/docs/writing.html)### Run server``` bash$ hexo server```More info: [Server](https://hexo.io/docs/server.html)### Generate static files``` bash$ hexo generate```More info: [Generating](https://hexo.io/docs/generating.html)### Deploy to remote sites``` bash$ hexo deploy```More info: [Deployment](https://hexo.io/docs/one-command-deployment.html) これで記事作成まで完了しました。 4) 確認・デプロイ① Localでブログ確認hexo serverコマンドを使うと、ウェブホスティングで公開する前に、ロケールで予めブログとコンテンツを確認できます。 123$ hexo serverINFO Start processingINFO Hexo is running at http://localhost:4000 . Press Ctrl+C to stop. ● localhost:4000 ● localhost:4000/2020/07/04/first-post/#more ② Deploy to Git Pageshexo deployコマンドを使うと、設定したGithubレポジトリに自動でプッシューしてくれます。 12345678$ hexo deployINFO Start processingINFO Files loaded in 101 ms...To https://github.com/{username}/{username}.github.io + 69bd38f...fa420ac HEAD -&gt; master (forced update)Branch 'master' set up to track remote branch 'master' from 'https://github.com/{username}/{username}.github.io'.INFO Deploy done: git ③ gitpagesのURLで確認Git Pagesとして動作しているレポジトリのMasterブランチにプッシューしたので、Github Actionでビルドが完了していると、https://{username}.github.ioにアクセスすると、確認できます。 これで、自分のブログが出来上がりました。 Extra) テーマ変更Hexoは、いろんなテーマから、いろんなデザインを適用できます。 ● Hexo Themehttps://hexo.io/themes/ 今回は、meilidu-hexoというテーマをダウンロードして、ブログのデザインを変えて見ます。 ① テーマインストール以下のレポジトリを参考し、テーマをインストールします。https://github.com/HoverBaum/meilidu-hexo 1git clone https://github.com/HoverBaum/meilidu-hexo.git themes/meilidu ② _config.ymlのtheme変更テーマの設定を変更します。 1234diff --git a/_config.yml b/_config.yml-theme: landscape+theme: meilidu ③ deploy &amp; GitPages 確認hexo cleanで、既存のベルドされたソースを消し、hexo deployで、新しくでビルド・デプロイします。 Github Actionsで、Git Pagesビルドが完了すると、テーマが適用されたことを確認できます。 12hexo cleanhexo deploy 後書き今回は、Git Pagesとhexoで、簡単なブログを作って見ました。 公開されているテーマをすこしカスタマイズして使うことだけでも、それなりのデザインと機能を備えた設置型ブログを無料で構築＆ホスティングできます。 Wordpressみたいな設置型ブログの機能には及ばずとも、完全に無料で設置型ブログを持つことが可能なのは、それなりに魅力的ではないでしょうか。 次は、Git Pagesと静的ページゼネレーターを利用して、簡単なウェブサービス的なものもチャレンジしてみたいですね。 皆様も、なにかGit Pagesと静的ページゼネレーターの良い活用事例があったら、ぜひ共有して頂けると嬉しいです。","link":"/2020/07/07/Git-Pages-Hexo%E3%81%A7%E6%89%8B%E8%BB%BD%E3%81%AA%E7%84%A1%E6%96%99Blog%E3%82%92%E4%BD%9C%E3%82%8B/"},{"title":"DockerでLAMP&amp;Redis環境を構築しながら、色々使い方を覚える","text":"やること1234567php-fpm(php7.4)centos7apache2.4mariadbphpMyadminnodejs (with Gulp)redis 上記の環境をDockerで構成する Dockerfileと各環境の設定ファイルを構成する docker-compose.ymlを構成する docker-composeで各環境のコンテナーを起動し内部状態を確認する Laravel上で、MariaDBとRedisのコネクションを確認する 全体ソースコードhttps://github.com/genie-oh/docker-lamp 参考にした記事&amp;Github レポジトリhttps://qiita.com/temori1919/items/487d68a19ca1de1a63c8https://github.com/temori1919/docker-lamp 基本レファレンスDockerfileのレファレンスhttps://docs.docker.com/engine/reference/builder/ Docker Composeのレファレンスhttps://docs.docker.com/compose/compose-file/ 1. Docker構成1) web構成 (centos &amp; apache)公式 dockerhubhttps://hub.docker.com/_/centos 構造12345docker-lamp/`-- web| |-- Dockerfile| |-- docker.conf # Copy to /etc/httpd/conf.d| `-- logs # for apache log web/docker.confApacheのconfig。主にバーチャルホスト関連設定を定義する。phpの処理はphp-fpmに任せるのでproxy設定をしておく。 1234567891011121314151617181920# rootdomain&lt;VirtualHost *:443&gt;... ServerName lamplocal.me VirtualDocumentRoot /var/www/html/home_root/public...&lt;/VirtualHost&gt;# subdomain. phpの動作が可能&lt;VirtualHost *:443&gt;... ServerName lamplocal.me ServerAlias *.lamplocal.me VirtualDocumentRoot /var/www/html/home_sub/%1/public &lt;FilesMatch \\.php$&gt; SetHandler &quot;proxy:fcgi://php:9000&quot; &lt;/FilesMatch&gt;...&lt;/VirtualHost&gt; web/Dockerfileapache.2.4のインストール任意のSSL認証書を作成docker.confをコンテナーにコピー 1234567891011# centos:7のイメージを元にコンテナーを作成FROM centos:7 # 指定のコマンド実行RUN ... # ホストシステムからコンテナーにファイルをコピーCOPY docker.conf /etc/httpd/conf.d/docker.conf # コンテナー起動時に実行するコマンドCMD [\"/usr/sbin/httpd\", \"-DFOREGROUND\"] 2) php構成 (php-fpm 7.4)公式 dockerhubhttps://hub.docker.com/_/php 構造12345docker-lamp/|-- php| |-- Dockerfile| |-- logs # For xdebug.log| `-- xdebug.ini # Copy to /usr/local/etc/php/conf.d xdebug.inixdebugの基本設定の他に、xdebug.logを残すように設定 1xdebug.remote_log=/var/log/xdebug/xdebug.log Dockerfile1234567891011121314# php:7.4-fpmのイメージを元にコンテナーを作成FROM php:7.4-fpm# phpのイメージで提供するユティリティの`docker-php-ext-install`,`docker-php-ext-enable`でPHP EXTENSTIONを設置RUN pecl install xdebug-2.8.1 \\ &amp;&amp; docker-php-ext-enable xdebug \\ &amp;&amp; docker-php-ext-install bcmath pdo_mysql# ホストシステムからコンテナーにファイルをコピーCOPY ./xdebug.ini $PHP_INI_DIR/conf.d/# 外部イメージから、コンテナーにファイルをコピー# 公式composerイメージから、phpコンテナーにcomposerを設置COPY --from=composer:latest /usr/bin/composer /usr/bin/composer 3) mariaDB構成公式 dockerhubhttps://hub.docker.com/_/mariadb 構造12345docker-lamp/|-- db| |-- Dockerfile| |-- logs # For slow query log| `-- my.cnf # Copy to /etc/mysql/conf.d my.cnf参考記事https://qiita.com/mamy1326/items/9c5eaee3c986cff65a55 charsetや、slow query log、wait timeout、その他innodb関連設定 12345678910default-character-set=utf8mb4character-set-server=utf8mb4# slow query logslow_query_log=trueslow_query_log-file=/var/log/mysql/mysql-slow.sqllong_query_time=1# コネクションタイムアウト時間wait_timeout=28800 Dockerfile12FROM mariadbCOPY my.cnf /etc/mysql/conf.d/my.cnf 4) redis構成公式 dockerhubhttps://hub.docker.com/_/redis 構成123456docker-lamp/|-- redis| |-- Dockerfile| |-- data # for redis data| |-- logs # for redis log| `-- redis.conf # Copy to /usr/local/etc/redis/redis.conf redis.confredis-serverの設定 参考記事https://qiita.com/uryyyyyyy/items/9ccadcccf7f7060d544a redisのログを残すように設定 1logfile &quot;/var/log/redis/redis-server.log&quot; Dockerfile1234FROM redisRUN mkdir /var/log/redisCOPY ./redis.conf /usr/local/etc/redis/redis.confCMD [ \"redis-server\", \"/usr/local/etc/redis/redis.conf\" ] 5) nodeの構成公式 dockerhubhttps://hub.docker.com/_/node 構成12|-- node| `-- Dockerfile Dockerfile123456789101112FROM node:latestRUN npm install -g gulp@3.9.1 gulp-phpunit config &amp;&amp; \\ npm install gulp@3.9.1 gulp-phpunit config &amp;&amp; \\ apt-get -y update &amp;&amp; \\ apt-get -y upgrade &amp;&amp; \\ apt-get -y install ca-certificates apt-transport-https &amp;&amp; \\ wget -q https://packages.sury.org/php/apt.gpg -O- | apt-key add - &amp;&amp; \\ echo \"deb https://packages.sury.org/php/ stretch main\" | tee /etc/apt/sources.list.d/php.list &amp;&amp; \\ apt-get -y update &amp;&amp; \\ apt-get -y install php7.2 php7.2-cli php7.2-common php7.2-opcache php7.2-curl php7.2-mbstring php7.2-mysql php7.2-zip php7.2-xmlWORKDIR /var/www/html 2. document root構成12345678910111213docker-lamp/|-- code # -- Mounted on /var/www/html| |-- config| | `-- default.json.example| |-- gulpfile.js| |-- home_root # -- root home| | `-- public # documentroot of lamplocal.jp| | `-- index.html # can run only static contents.| |-- home_sub # -- virtual host home| | `-- test # you can add directory &amp; use by subdomain| | `-- public # documentroot of test.lamplocal.jp| | `-- index.php # can run php script| `-- nodeapp 3. docker-compose.yml構成123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172version: '3.7'services:# centos7 apache2.4.*(http2) web: build: ./web container_name: lamp-web ports: - '443:443' volumes: - ./code:/var/www/html - ./web/logs:/var/log/httpd - cert:/etc/ssl/private restart: always env_file: .env# php-fpm 7.4 php: build: ./php container_name: lamp-php ports: - '9000' volumes: - ./code:/var/www/html - ./php/logs:/var/log/xdebug restart: always env_file: .env# mariaDB db: build: ./db container_name: lamp-db restart: always env_file: .env ports: - 3306:3306 volumes: - ./db/logs:/var/log/mysql - datastore:/var/lib/mysql# phpMyadmin phpmyadmin: container_name: lamp-phpmyadmin image: phpmyadmin/phpmyadmin env_file: .env ports: - 8080:80 depends_on: - db# node js (include gulp) node: build: ./node container_name: lamp-node restart: always tty: true environment: - NODE_ENV=production ports: - '3000:3000' volumes: - ./code:/var/www/html depends_on: - web# redis server redis: build: ./redis container_name: lamp-redis restart: always ports: - '6379:6379' volumes: - \"./redis/data:/data\" - \"./redis/logs:/var/log/redis\"volumes: cert: datastore: 4. 動作確認aliasを使っていますが、実行コマンドはexecute :で出力しているので参考にしてください。 alias設定の内容と各命令の解説はこちらを参考できます。https://qiita.com/genie-oh/items/266857d788a85e2da8f9 1) build12345678910111213141516171819202122232425$ al dockiexecute : docker imagesREPOSITORY TAG IMAGE ID CREATED SIZE$ al dockcbexecute : docker-compose buildphpmyadmin uses an image, skippingBuilding web......Successfully built 43bb05ec0f39Successfully tagged docker-lamp_redis:latest$ al dockiexecute : docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEdocker-lamp_redis latest 43bb05ec0f39 About a minute ago 104MBdocker-lamp_node latest 1cffc83ebe6f About a minute ago 1.06GBdocker-lamp_db latest e112492cc9c2 4 minutes ago 407MBdocker-lamp_php latest 5a3452fcbf58 4 minutes ago 671MBdocker-lamp_web latest 9af33e8e4219 9 minutes ago 540MB... 2) run containers12345678910111213141516171819202122$ al dockcuexecute : docker-compose up -d...Status: Downloaded newer image for phpmyadmin/phpmyadmin:latestCreating lamp-web ... doneCreating lamp-php ... doneCreating lamp-redis ... doneCreating lamp-db ... doneCreating lamp-node ... doneCreating lamp-phpmyadmin ... done$ al dockpsexecute : docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESea93226c6b49 phpmyadmin/phpmyadmin \"/docker-entrypoint.…\" 17 seconds ago Up 14 seconds 0.0.0.0:8080-&gt;80/tcp lamp-phpmyadmin52a68fde7bdd docker-lamp_node \"docker-entrypoint.s…\" 17 seconds ago Up 14 seconds 0.0.0.0:3000-&gt;3000/tcp lamp-node13e52a01700e docker-lamp_php \"docker-php-entrypoi…\" 19 seconds ago Up 16 seconds 0.0.0.0:32837-&gt;9000/tcp lamp-php43eb81b6410e docker-lamp_web \"/usr/sbin/httpd -DF…\" 19 seconds ago Up 15 seconds 0.0.0.0:443-&gt;443/tcp lamp-web473ffaf3439b docker-lamp_redis \"docker-entrypoint.s…\" 19 seconds ago Up 15 seconds 0.0.0.0:6379-&gt;6379/tcp lamp-redisae80a8fd00c6 docker-lamp_db \"docker-entrypoint.s…\" 19 seconds ago Up 15 seconds 0.0.0.0:3306-&gt;3306/tcp lamp-db 3) access web12345$ curl -k https://lamplocal.me --silent | grep \"&lt;title&gt;\" &lt;title&gt;Hello World&lt;/title&gt;$ curl -k https://test.lamplocal.me --silent | grep \"&lt;title&gt;\"&lt;title&gt;PHP 7.4.7 - phpinfo()&lt;/title&gt;&lt;meta name=\"ROBOTS\" content=\"NOINDEX,NOFOLLOW,NOARCHIVE\" /&gt;&lt;/head&gt; 4) check each package version in container12345$ al dockeit lamp-web httpd -vexecute : docker exec -it lamp-web httpd -vServer version: Apache/2.4.41 (IUS)Server built: Aug 25 2019 19:41:04 1234567$ al dockeit lamp-php php -vexecute : docker exec -it lamp-php php -vPHP 7.4.7 (cli) (built: Jun 11 2020 18:41:17) ( NTS )Copyright (c) The PHP GroupZend Engine v3.4.0, Copyright (c) Zend Technologies with Xdebug v2.8.1, Copyright (c) 2002-2019, by Derick Rethans 1234$ al dockeit lamp-db mysql --versionexecute : docker exec -it lamp-db mysql --versionmysql Ver 15.1 Distrib 10.5.4-MariaDB, for debian-linux-gnu (x86_64) using readline 5.2 1234$ al dockeit lamp-redis redis-server -vexecute : docker exec -it lamp-redis redis-server -vRedis server v=6.0.5 sha=00000000:0 malloc=jemalloc-5.1.0 bits=64 build=db63ea56716d515f 1234$ al dockeit lamp-node node -vexecute : docker exec -it lamp-node node -vv14.5.0 5) down containers12345678910111213141516$ al dockcdexecute : docker-compose downStopping lamp-phpmyadmin ... doneStopping lamp-node ... doneStopping lamp-php ... doneStopping lamp-web ... doneStopping lamp-redis ... doneStopping lamp-db ... doneRemoving lamp-phpmyadmin ... doneRemoving lamp-node ... doneRemoving lamp-php ... doneRemoving lamp-web ... doneRemoving lamp-redis ... doneRemoving lamp-db ... doneRemoving network docker-lamp_default 6) 特定コンテナーのみ実行1234$ dockcu php dbCreating network \"docker-lamp_default\" with the default driverCreating lamp-php ... doneCreating lamp-db ... done 7) php, mariadb, redis 連携確認laravelをインストールし、各コネクションを確認 1234567891011# docker-lamp\\code\\home_sub\\cgi\\.envDB_CONNECTION=mysqlDB_HOST=lamp-dbDB_PORT=3306DB_DATABASE=laravelDB_USERNAME=rootDB_PASSWORD=rootpwREDIS_HOST=lamp-redisREDIS_PASSWORD=nullREDIS_PORT=6379 1234567891011121314151617# docker-lamp\\code\\home_sub\\cgi\\app\\Http\\Controllers\\TestController.php&lt;?phpnamespace App\\Http\\Controllers;use Illuminate\\Support\\Facades\\Redis;use Illuminate\\Support\\Facades\\DB;class TestController extends Controller{ public function index () { $redisResult = Redis::connection()-&gt;ping('redis pong'); $dbResult = DB::table('test')-&gt;get(); return view('test/index', compact('redisResult', 'dbResult')); }} 123$ curl -k https://cgi.lamplocal.me/testredisResult : redis pongdbResult : [{\"id\":0,\"name\":\"abc\"}] 後書き 違うプラットフォームの開発完了などをDockerでコード化しておくと、いろんな開発環境に柔軟に対処できるのはいい。 PythonやJava、Full Stack Javascript環境も構成してコード化しておきたい。 機会があれば、Dockerイメージのサービスデプロイ＆運用も勉強したい。（Kubernate, AWS ECS）","link":"/2020/07/11/Docker%E3%81%A7LAMP-Redis%E7%92%B0%E5%A2%83%E3%82%92%E6%A7%8B%E7%AF%89%E3%81%97%E3%81%AA%E3%81%8C%E3%82%89%E3%80%81%E8%89%B2%E3%80%85%E4%BD%BF%E3%81%84%E6%96%B9%E3%82%92%E8%A6%9A%E3%81%88%E3%82%8B/"},{"title":"vscode・Emmet Snippetでhtml,cssを手っ取り早くかく","text":"やること vscodeに基本提供されているemmet snippetsを使い、手っ取り早くhtml, cssを書くことを試みる emmetはどういうものかをざっくり目を通す vscodeのEmmet Snippetsとは？https://code.visualstudio.com/docs/languages/html#_emmet-snippets vscodeは、基本的にemmetのauto-completionを提供している。 htmlのauto-completion例1ul&gt;li*3&gt;span.hello$ を書くと 12345&lt;ul&gt; &lt;li&gt;&lt;span class=\"hello1\"&gt;&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span class=\"hello2\"&gt;&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span class=\"hello3\"&gt;&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt; こういうふうに、HTMLを自動で完成してくれる。 cssのauto-completion例1p10 を書くと 1padding: 10px; こういうふうに、css属性を自動で完成してくれる。 EmmetとはEmmetは既定形式の入力補完機能によりHTML、XML、XSL等を素早く編集できる、テキストエディタ用プラグインvscodeは、このプラグインを基本搭載している。 Emmetでできることhtml, css, xslのauto-completion Emmet DocumentsCheat Sheetsのいくつかを覚えておくと便利 ● Cheat Sheets(html, css, xsl)https://docs.emmet.io/cheat-sheet/ ● Syntax &amp; Documentationhttps://docs.emmet.io/abbreviations/syntax/","link":"/2020/07/11/vscode%E3%83%BBEmmet-Snippet%E3%81%A7html-css%E3%82%92%E6%89%8B%E3%81%A3%E5%8F%96%E3%82%8A%E6%97%A9%E3%81%8F%E3%81%8B%E3%81%8F/"},{"title":"PHP・GCの話-3話)変数データのメモリからの消滅","text":"前書き すべての記事は、自分の勉強目的と主観の整理を含めています。あくまで参考レベルで活用してください。もし誤った情報などがあればご意見をいただけるととっても嬉しいです。 内容では、省略するか曖昧な説明で、わかりづらいところもあると思います。そこは、連絡いただければ補足などを追加するので、ぜひ負担なくご連絡ください。 本文での「GC」は、「Garbage Collection, Garbage Collector」の意味しており、略語として使われています。 この記事は、連載を前提に構成されています。 ※ 連載目録 PHP・GCの話-1話)なぜGarbageCollection? メモリとGCを意識する PHP・GCの話-2話)変数の管理情報、zval containerとreference count PHP・GCの話-3話)変数データのメモリからの消滅 （←現在の記事） PHP・GCの話-4話)MemoryLeakと解除できない変数データ ⇨ 準備中 PHP・GCの話-5話)GC登場。GC発生条件とroot buffer ⇨ 準備中 PHP・GCの話-6話)管理対象の巡回・削除。Garbage Collection Cycle ⇨ 準備中 PHP・GCの話-7話)GC関連機能紹介(GC Statistics, Weak Reference Type)(END) ⇨ 準備中 ※ 連載で使うサンプルコード Sample Code Link on Github ● ExampleGc.php : 2話から6話までの内容で使うサンプルコードです。● ExampleWeakReference : 7話のWeakReferenceの内容で使うサンプルコードです。 本連載記事は、基本的にこのサンプルコードをベースに説明をしています。サンプルコードは、必ず見る必要も実行してみる必要もありません。各話ごとに、コードを分解して動作原理と結果を解説しますので、基本記事の内容で足りるように心がけます。あくまで、全体コードをみたい、手元で回してみたい、修正して回してみたいという方向けです。 今回の話今日は、PHPの変数の消滅に関して、以下のものを話そうと思うます。 変数のデータの消滅条件 変数のデータの消滅しない条件 Summary 1. 変数のデータの消滅条件私達が定義し使った変数の実際のデータは、消滅しないと、いつまでもメモリを専有します。なので、開発言語は、適切に変数を消滅させるためのメカニズムが存在します。 PHPで、変数の実際のデータが消滅する条件は以下に定義できます。 ① 「実際のデータの参照が一つ無効になる」時、zvalの参照カウント(zvalのrefcount)を-1した結果、0であればデータはメモリから消滅する。② Garbage Collection Cycleの結果、参照カウントが0であれば、データはメモリから消滅する。 ※ ②は、これから知っていくので、今は気にしなくて大丈夫です。 では、①の「実際のデータの参照が一つ無効になる」に関してですが、PHPでは、以下のメカニズムが働き、参照カウントが0であれば、データは消滅することになります。参照カウント(refcount)が「0」であれば、データは消滅するという前提条件があることを意識して読んでいただくと良いと思います。 1) 変数の有効範囲の消滅PHPの変数の有効範囲は、一部のケースを除いては「関数単位の単一範囲」になります。※1その有効範囲から逃れる時、有効範囲自体の消滅と同時に、有効範囲内の変数シンボルは解除され、実際のデータの参照も無効になります。 12345function someFunc() { $local = 'a'; //$localは、function{}の範囲内で有効です。}someFunc(); // 関数の遂行が合わったあと、a関数内の$localは自動的に解除されます。 2) 明示的な変数シンボルの解除(unset)phpでは、変数シンボルの解除の機能の持つ関数としてunset()という関数を提供しています。これは、あくまで該当変数シンボルを解除し、その変数の参照を無効にするだけで、変数データが消滅するか否かは、参照カウントによって決まることを意識すると良いです。 1unset ( mixed $var [, mixed $... ] ) : void 3) 変数シンボルの参照再設定変数シンボルの参照が再定義されると、以前の参照は無効になります。 12$a = array(0);$a = array(1); //この時、$aの変数の参照がarray(1)に上書きされ、array(0)に対する参照は無効になります。 2. 変数の消滅しない条件逆に言いますと、変数が消滅しない条件というのは、以下と言えます。 「実際のデータの参照が一つ無効になる」時、参照カウント(refcount)が「1以上」であれば、データは消滅せずに残り続ける。 上記の条件になるケースを例えれば、以下のようなものがあります。 しかし、本内容は、該当のスコープからの解除時点でデータが消えないというだけであって、別のスコープで「変数の消滅条件」を満たし、明示的に消滅されることができるということを前提として参考にしてください。※2 1) 同じスコープで、同じデータを参照する変数がある場合同じ関数内などの同じスコープで、同じデータを参照する変数が複数存在する場合、一つの変数が解除されても、データは消滅しません。 12345$a = array(0);$b = $a;unset($a); var_dump($b); //$aの変数を解除しても、$bがarray(0)の参照を持っているため、消滅しません。 2) 違うスコープで、同じデータを参照する変数がある場合関数の引数として渡された場合などは、上位スコープでまだデータを参照しているため、現在のスコープから変数が解除されても、データは消えません。 ここに関しては、引数渡しでのValue CopyとReference Copyの内容を参考にすると良いです。 12345678function x(object $obj) { unset($obj); //現在のスコープの$objに対する参照は解除されます //しかし、上位スコープにいる$aの変数の参照がまだ有効なため、データは消滅しません。}$a = array(0);x($a); 3) compound typeの変数の内部で、同じデータを参照する変数がある場合array, objectなどのcompound typeは、内部にデータは参照を持つことができます。その内部でデータを参照していると、データは消滅しません。 12345678function x(object $obj) { $data = array(0); $obj-&gt;data = $data; //$dataは、x関数の遂行後に解除されますが、stdClassのインスタンスのメンバーとして、array(0)データを参照することになり、データは消滅しません。}$a = new \\stdClass;x($a); 3. Summary今回で、最低限に覚えて頂くと良い内容は以下になります。 参照カウント(refcount)が、0であればデータはメモリから消滅する。 参照カウント(refcount)が、1以上であれば、データは消滅せずに残り続ける。 後書き今回は、変数の消滅条件に関してお話をしました。 「既存の内容を参照カウント(refcount)の観点で再整理してみた」ということに目的がありますが、読んで頂く方の中では少しベタで当たり前だと感じるかもしれない内容に関して話した気もします。 その反面、他の方には逆に、少し不明なところがあるかもしれません。そういう時には、連絡頂けると補足いたしますので宜しくお願いします。 次回は、MemoryLeakと解除できない変数データに関して扱うことになります。 ※注釈 ※1▶ PHPの変数の有効範囲は、一部のケースを除いては「関数単位の単一範囲」になります 一部のケースというのは、global scopeや、内部的に他のデータの参照を持つcompound type(object, array)の変数などなどを意味します。 ※2▶ 別のスコープで「変数の消滅条件」を満たし、明示的に消滅されることができるということを前提として参考にしてください。 ここでみたケースは、上位のスコープとかでプログラマーが明示的に消滅させることができますので、「永遠に消滅しない」という訳ではありません。しかし、GCなどの仕組みがなかったら、永遠に消滅しない変数データが、プログラマーの手で発生するケースもあります。その一つが、次回に扱う内容のMemory Leakと言えます。","link":"/2020/08/22/PHP%E3%83%BBGC%E3%81%AE%E8%A9%B1-3%E8%A9%B1-%E5%A4%89%E6%95%B0%E3%83%87%E3%83%BC%E3%82%BF%E3%81%AE%E3%83%A1%E3%83%A2%E3%83%AA%E3%81%8B%E3%82%89%E3%81%AE%E6%B6%88%E6%BB%85/"},{"title":"PHP・GCの話-1話) なぜGarbageCollection? メモリとGCを意識する","text":"前書き すべての記事は、自分の勉強目的と主観の整理を含めています。あくまで参考レベルで活用してください。もし誤った情報などがあればご意見をいただけるととっても嬉しいです。 内容では、省略するか曖昧な説明で、わかりづらいところもあると思います。そこは、連絡いただければ補足などを追加するので、ぜひ負担なくご連絡ください。 本文での「GC」は、「Garbage Collection, Garbage Collector」の意味しており、略語として使われています。 この記事は、連載を前提に構成されています。 ※ 連載目録 PHP・GCの話-1話)なぜGarbageCollection? メモリとGCを意識する（←現在の記事） PHP・GCの話-2話)変数の管理情報、zval containerとreference count ⇨ 準備中 PHP・GCの話-3話)変数データのメモリからの消滅 ⇨ 準備中 PHP・GCの話-4話)MemoryLeakと解除できない変数データ ⇨ 準備中 PHP・GCの話-5話)GC登場。GC発生条件とroot buffer ⇨ 準備中 PHP・GCの話-6話)管理対象の巡回・削除。Garbage Collection Cycle ⇨ 準備中 PHP・GCの話-7話)GC関連機能紹介(GC Statistics, Weak Reference Type)(END) ⇨ 準備中 ※ 連載で使うサンプルコード Sample Code Link on Github ● ExampleGc.php : 2話から6話までの内容で使うサンプルコードです。● ExampleWeakReference : 7話のWeakReferenceの内容で使うサンプルコードです。 はじめに今回は概論と本人の持論が主な話になります。メモリとGCに対する知識を既にお持ちの方は、すぐに次の話から読んで頂いても良いと思います。２話からは、PHPの仕様に基づいた客観的な内容が主になります。 1. GCは何をするの？ GCとは、一言で「メモリ内のゴミ自動回収仕組み」と言えます。それを意識しながら内容をご覧いただけると良いと思います。 この概念は、日常生活のゴミ捨てとかなり似ています。 呼ばなくても、回収に来てくれる。(自動回収) 毎週、指定日に回収に来てくれる。（GC発動条件） もし、上記の仕組みがなかったら、私達はゴミ処理において相当苦しみを感じたと思います。 GCは、プログラムが使うメモリ空間において、ほぼ似たような役目を遂行します。 プログラム内のメモリ空間内のゴミ状態の参照や変数を、特定条件が達したタイミングで自動でメモリから解除し、メモリ空間を広く確保してくれます。「エンジニアが明示的に解除しなくても」やってくれるのが核心です。 2. なぜGCを知る必要があるの？1) PHPにおいてのGCは重要？実のところPHPは、JAVA・TOMCAT基盤などのシ資源共有型のマルチスレッドステムとは違い、一つのリクエストに対して単体プロセスとして実行させ終了する形で使われる場合が多いです。こういう単体プロセスで処理されるタイプの場合は、プロセス終了とともにすべてのメモリ専有が解除されるため、Memory LeakとGCに対するトラブルで大きい問題になる場合は少ないです。 しかし最近のPHPは、 パッケージやフレームワークをベースとした開発によりプログラムのサイズは増大 バッチ系やデーモン系の大容量処理プログラムなどのニーズも多くなったこと により、PHPにおいてのメモリ管理の関心は高くなっていると思うので、軽く知っておいても良いと思っています。 2) GCは多くの言語においての「メモリ管理メカニズム」 GCは、プログラム開発分野において、ある程度「共通認識」になったと言っても過言では無いと思います。 プログラムを作ることにおいて、メモリ管理というのは、昔から多く語られる課題と言えます。最近の開発言語は、エンジニアがメモリ管理に多く気にしなくてもいいように、仮想マシーンやインタプリタなどの言語プラットフォームが大半を管理してくれます。 PHPはメモリ管理メカニズムの一つとして、GCを導入しています(Version 5.3以降)。PHP以外にも、Java(Kotlin)，C#、Python，Go, Rustなどなどの言語から、具現体により差はあるかもですが、大人気のJavascriptもまたGCのメカニズムを導入しています。 3) それでもメモリは有限である12Symfony\\Component\\ErrorHandler\\Error\\FatalError Allowed memory size of 134217728 bytes exhausted (tried to allocate 83886112 bytes) 私達はプログラムを作る時、ある情報を保存・取得・処理・提供するため、様々な情報を変数としてアサインしています。 その情報はシステムマシーンの「メモリ」と言う空間に保存されます。そして変数の大きさに比例し一定の空間を占有します。 しかし、メモリは物理的な空間であり、容量の限界があります。もしメモリが足りなくなり、それを放置すればシステムはダウン状態に落ち、トラブルになります。 特に最近は、開発トレンドが、フレームワークやパッケージ組み合わせ開発が主類になっています。そこで生産性と大型システム開発の容易性は飛躍的に上がりましたが、必要以上の機能を搭載することにより平均的にはプログラムが要求するシステム資源もまた上がっています。 PHP、OSや、クラウドサービス（例：AWS）などでそれを防ぐために用意された仕組みが色々あります。しかし、それだけに依存するのは制約・費用・運用面で、長期的に色々デメリットを起こす可能性が高いので、すごく損することだと言えます。 4) GCも万能の神様ではないGCも万能ではなく、エンジニアがメモリを全く気にしない実装をすると、時々に、すごく難題の欠陥を作ったりします。自分が考えるたとえとしては以下の3つがあります。 PHPでは、要請を独立したプロセスで処理する場合が多いので、影響は少ないかもですが、無関係では無いところと、他の言語でのGCを見る観点としては、役に立つと思うので、参考までにご覧ください。 ● GCの発動条件。常に発動するわけではない。 言語によってGCの発動条件はそれぞれ違いますが、常に発動しているわけではありません。つまり、GCが発動する前に、メモリが足りなくなり、プログラムが落ちてしまうことは全然ありです。 PHPの例えを簡単に引用すると、PHPはメモリ解除候補が10000個に達した条件でGCが発動しますが、条件に達する前にメモリ制限の容量まで達してしまうと、プログラムがMemoryLimitErrorで落ちてしまいます。（PHPのGC発動条件に対しては、後ほど詳しく扱う予定です。） ● GCが発生すると言うのはすでにメモリ空間においての赤信号！ GCの発生条件ともつながる話ですが、GCが発生するという状態は、「ついにメモリを回収しないと行けない状況になってしまった」という状態であることを肝に銘じる必要があります。※1 ● GCが発動して終わるまで、プログラムがフリーズするか、システム負荷が相当かかる！ GCの発生と遂行は、プログラムにおいての最優先処理事項として遂行されます。つまり、該当プロセスのすべての作業を止めて、GCを遂行するということを意味します。GCで回収している間は、プログラムがメモリ空間を使ってしまったら整合性が崩れるからです。しかしGCは相当重い処理であり、時々相当時間がかかってしまう場合もあります。GCに時間がかかっている間、プログラムはFreeze状態になります。それは、つまり処理の遅延を意味し、ユーザーサービスにおいては、敏感な問題になります。 5) メモリ最適化は、関心度が高い課題PHPに例えるなら、 Version 5.3から、GCメカニズムを導入し、 Version 7では、Weak Reference Typeを提供し、 Version 8では、WeakMap Typeを提供する予定（RFC確定） で、PHP内でもメモリ最適化の関心度は高いと思っています。そして、PHPだけじゃなく開発全般において、関心度が高いものだと言えます。 それを少しでも意識しておくことは、開発全般においてもメリットになると思ってます。 6) メモリとGCを少しでも意識した上で、プログラムを作り運用するメモリとGCを意識したシステム作りと運用は、長期的にマシーン性能にかかるコストと、メモリ関連問題発生時の運用コストの節減につながると思います。 特にメモリに関わる欠陥問題は、事前検知が難しい場合も多く、起きたとしても原因特定と解決に苦難する場合が多いです。 なので、メモリとGCを意識するのは、 難しい欠陥問題に対する予防策であり、 問題が起きたときの対処ノウハウにもつながる。 のではないでしょうか。 3. 「PHP・GCの話」では何をやるの？1) 事前に知っておいたらいいのは？以下の内容を事前に熟知しておくと、記事を見ることに役立つと思います。 PHPとOOPの基本概念 変数・参照変数の基本概念 システムマシーンのメモリの基本概念 GCの基本概念（当記事や、Wikipediaなどの内容でOK、1ページ以下で収まるような内容がおすすめ） 2) 連載で扱う内容のオーバービュー PHP・GCの話-1話)なぜGarbageCollection? メモリとGCを意識する GCの役目、GCをなぜ知る必要があるかの持論と概論で構成されています。 PHP・GCの話-2話)変数の管理情報、zval containerとreference count PHPの変数管理のメカニズムと、参照カウントの概念を説明します。 PHP・GCの話-3話)変数データのメモリからの消滅 変数のデータが消滅してメモリが確保される条件を説明します。 PHP・GCの話-4話)MemoryLeakと解除できない変数データ 無効になってもなお、メモリから解除されず、残り続ける現象について説明します。 PHP・GCの話-5話)GC登場。GC発生条件とroot buffer GCの役目、発動条件、GC監視対象を保存するroot buffer仕様を説明します。 PHP・GCの話-6話)管理対象の巡回・削除。Garbage Collection Cycle GCがどういうメカニズムでGC監視対象のデータを巡回し、解除するとかを説明します。 PHP・GCの話-7話)GC関連機能紹介(GC Statistics, Weak Reference)(END) GC分析ツールと、Weak Reference(&gt;PHP7.4), WeakMap(&gt;PHP8)を簡単に説明します。 3) 参考した資料は？主ににPHP MANUALを参考にしています。https://www.php.net/manual/en/features.gc.phphttps://www.php.net/manual/en/langref.php 4) 連載に使うサンプルコード Sample Code Link on Github ● ExampleGc.php : 2話から6話までの内容で使うサンプルコードです。● ExampleWeakReference : 7話のWeakReferenceの内容で使うサンプルコードです。 GCに関する本連載記事は、基本的にこのサンプルコードをベースにPHP-GCの特徴をはなしていきます。 サンプルコードは、必ず見る必要も実行してみる必要もありません。各話ごとに、コードを分解して動作原理と結果を解説しますので、基本記事の内容で足りるように心がけます。あくまで、全体コードをみたい、手元で回してみたい、修正して回してみたいという方向けです。 そして、このサンプルコードは、あくまでGC説明のため用意されたコードなので、書き方としてはよくないパターンもあります。コードの完成度よりも、GCの動作理解の参考までにご活用ください。 加えて、本コードはlaravelフレームワークをベースに作成されていますが、Laravel自体を詳しく知る必要はありません。そして、あくまでGCの開設のため書かれたコードで、実用性のあるコードではあることをご理解ください。 反面、そのコードを見て、 コード動作で、内部でどういうものが起きるのか？ どういうケースになれば、メモリが足りなくなり、問題が発生しそうなのか？ 使われた参照変数はどういう関係図になるのか？ どこで変数の有効範囲が切れるか？メモリリークはどこで起きるか？ どういう絵図で、zvalとroot zval, Garbage Collection CycleのGC対象巡回が行われるのか？ 弱参照タイプとは？ に関してすでにご存知の方は、当連載記事の大半の内容をすでにご存知の方なので、読む必要はあんまり無いかもしれません。 Summary今回で、最低限に覚えて頂くと良い内容は以下になります。 GCは「メモリ・自動回収仕組み」 GCは、プログラム開発においての共通認識 メモリは有限である GCも万能ではない 今回の後書き今回は主観的持論や概論を主に話しましたが、こういう系の記事が一番むずかしい気がします。なので自分としては、今の記事の細かな内容よりも、「GCの役目」と「なぜGCを知る必要があるか？」の問を心のどこかでとどめていただければ、嬉しいと思っております。 次回からは、主にPHPに絞ったGCの話をやっていきます。実際のサンプルコードを使いづつ、今回の話よりは客観的な内容になると思います。だからこそGCに対して、読者自身の主観を持った上で見ていただけることで、より効果的な情報共有することができるという思いで、今回の話を書いてみました。 では、次回も頑張って整理していきたいと思います。 ※注釈 ※1▶ 「ついにメモリを回収しないと行けない状況になってしまった」という状態であることを肝に銘じる必要があります。 比較的に最近までは、GCが起きることは赤信号という風にみることもでき、特に古いシステムではよくトラブルになるポイントとなっていました。しかし、厳密にいうとこの内容は、もう100％当てはまりません。最近はJavaのG1GC(Garbage First GC)は短い周期でGCを起こし、オーバーヘットを最低限にするとかもしており、JAVA1.9からはデフォルトで推奨されています。近いうちには、この内容が大きく変わるかもしれません。","link":"/2020/08/10/PHP%E3%83%BBGC%E3%81%AE%E8%A9%B1-1%E8%A9%B1-%E3%81%AA%E3%81%9CGarbageCollection-%E3%83%A1%E3%83%A2%E3%83%AA%E3%83%BC%E3%81%A8GC%E3%82%92%E6%84%8F%E8%AD%98%E3%81%99%E3%82%8B/"},{"title":"Typescript書き方の速成まとめ","text":"目次 1. 概論・セットアップ 2. tsconfig 3. TypeScript Basic Types 4. var, let, const 5. Type Assertion 6. Type Alias 7. Interface 8. Class 9. Generic 10. keyof -Lookup Types- 11. Iterator 12. Decorator 13. Type Inference 1. 概論・セットアップ transpile言語 (類似コンパイル言語) Javascriptと交換 Typescriptの主な役目 コンパイル時にタイプチェックを行うこと Typescript setup &amp; compile1234567891011# 初期化npm init -ynpm -i typescript [-g]%init tsconfig.json./node_modules/.bin/tsc --init # compiletsc {filename} # watch &amp; auto compile, 実用的ではない(glup推奨)tsc -w typescript online playhttps://www.typescriptlang.org/play 2. tsconfighttp://json.schemastore.org/tsconfig ● Top Level Properties 1234567compileOptions ★compileOnSave //boolean : セーブと同時にコンパイル(IDE)extends //relative pathfiles //path(glob)include //path(glob)exclude //path(glob)typeAcquisition compileOptions : type TypeScript2からサポートするType Definition System関連オプション 何も設定しないと、自動で./node_nodules/@types/*をインポート ex: ./node_nodules/@types/react/*, ./node_nodules/@types/babel__*/* @typesは、コンパイル時のタイプチェックはもちろん、IDEのコードアシスト、シンタクスチェックなどでも使われる大事な定義ファイル typeRoots 設定すると、設定したパスだけインポート types 設定すると、配列内に指定したモジュール、または./node_nodules/@types/内のモジュール名から探す。 []だと使わない typeRootsはtypesは、どっちか一つだけ使う。 12345678910\"typeRoots\": { \"description\": \"Specify list of directories for type definition files to be included. Requires TypeScript version 2.0 or later.\", \"type\": \"array\", ...},\"types\": { \"description\": \"Type declaration files to be included in compilation. Requires TypeScript version 2.0 or later.\", \"type\": \"array\", ...}, compileOptions : target, lib target buildするバージョンを指定 指定しないと、基本esバージョン lib 基本type difinitionライブラリを指定 指定しないと、esバージョンに依存したライブラリを使用 指定すると、指定したライブラリのみを使う 12345678910\"target\": { \"description\": \"Specify ECMAScript target version: 'ES3', 'ES5', 'ES6'/'ES2015', 'ES2016', 'ES2017', 'ES2018', 'ES2019', 'ES2020', 'ESNext'\", \"type\": \"string\", ...},\"lib\": { \"description\": \"List of library files to be included in the compilation. Possible values are: 'ES5', 'ES6', 'ES2015', 'ES7', 'ES2016', 'ES2017', 'ES2018', 'ESNext', 'DOM', 'DOM.Iterable', 'WebWorker', 'ScriptHost', 'ES2015.Core', 'ES2015.Collection', 'ES2015.Generator', 'ES2015.Iterable', 'ES2015.Promise', 'ES2015.Proxy', 'ES2015.Reflect', 'ES2015.Symbol', 'ES2015.Symbol.WellKnown', 'ES2016.Array.Include', 'ES2017.object', 'ES2017.Intl', 'ES2017.SharedMemory', 'ES2017.String', 'ES2017.TypedArrays', 'ES2018.Intl', 'ES2018.Promise', 'ES2018.RegExp', 'ESNext.AsyncIterable', 'ESNext.Array', 'ESNext.Intl', 'ESNext.Symbol'. Requires TypeScript version 2.0 or later.\", \"type\": \"array\", ...}, compileOptions : outDir, outFile12345678\"outDir\": { \"description\": \"Redirect output structure to the directory.\", \"type\": \"string\"},\"outFile\": { \"description\": \"Concatenate and emit output to single file.\", \"type\": \"string\"}, compileOptions : module module compileされた結果物のモジュールシステムを指定 targetがes6だと、es6がデフォルト targetがes６じゃないとcommonjsがデフォルト moduleResolution tsソースで使用されるモジュールを指定 CommonJSの場合Node、それ以外はだいたいClassic pathsと baseUrl 指定すると、該当パスのモジュールをロード 普通使わなくてOK。（細かいモジュール連携に必要） rootDirs ロードするモジュールのルートパス配列 普通使わなくてOK。（細かいモジュール連携に必要） 123456789101112131415161718192021222324252627282930\"module\": { \"description\": \"Specify module code generation: 'None', 'CommonJS', 'AMD', 'System', 'UMD', 'ES6', 'ES2015', 'ES2020' or 'ESNext'. Only 'AMD' and 'System' can be used in conjunction with --outFile.\", \"type\": \"string\", ...},\"moduleResolution\": { \"description\": \"Specifies module resolution strategy: 'node' (Node) or 'classic' (TypeScript pre 1.6) .\", \"type\": \"string\", ...},\"baseUrl\": { \"description\": \"Base directory to resolve non-relative module names.\", \"type\": \"string\"},\"paths\": { \"description\": \"Specify path mapping to be computed relative to baseUrl option.\", \"type\": \"object\", \"additionalProperties\": { \"type\": \"array\", \"items\": { \"type\": \"string\", \"description\": \"Path mapping to be computed relative to baseUrl option.\" } }},\"rootDirs\": { \"description\": \"Specify list of root directories to be used when resolving modules.\", \"type\": \"array\", ...}, 3. TypeScript Basic TypesTypeScriptで定義した基本データタイプUser Defined Typesも、基本データタイプからの拡張 superset (ECMAScript Standard) boolean, number, string, null, undefined array (object, non-primitive) symbol (ecma6) 固有で修正不可能なデータとしてアサイン primitive値を指定 Subtypes undefined &amp; nullは、すべてのタイプに対してのサブタイプ すべてのタイプに、undefinedとnullはアサインできる。 しかし、compileOptionで, --strictNullChecksを使うと、voidか、自分自身にだけアサインでできるようになる。 その場合は、union typeで指定しなきゃいけない。 ex : let union: string | null | undefined = 'str' Additional Type void タイプがない、空の概念 関数のリターンタイプくらいで使う（リターンする値がない時） any 何のタイプにもなれる Anyは非推奨、TypeScriptを使う意味が薄れる。 compileOptionで、エラーになるように指定も可能(noImplicitAny) never 結果を返さないため、タイプを持たない。 あんまり使うところがないが、関数のリターンタイプくらいで使う infinitely loop function absolutely throw Error absolutely return error(‘message’) enum 列挙型(他の言語と同じ) 複数の変数に対して、一連の定数値をアサイン enum Color {Red, Green, Blue}; let c: Color = Color.Red; let colorName: string = Color[c]; tuple (object, non-privitive) 複合タイプを持つ配列 let x: [string, number] =['hello', 10]; 値を持って使うときに、どういうタイプかチェックしない限りわからないため、使うのに注意は必要 Union Type タイプの共用体 let someVar: string | number | boolean = false Type Assigned by literal Literal値で、タイプを定義するのも可能。指定したLiteralのみ設定可能 let someVar: &quot;a&quot; | 5 | false = 5 Genericパートで記述するkeyof (Indexed Type Query)演算子の理解とつながる。 4. var, let, constVS var, let, const var ES5 variable scope : function hoisting : O re-difinition : O let, const ES6 variable scope : block hoisting : X re-difinitio : X varより、let, const推奨 コード分析が直感的になる letとconstのタイプ推論 let a: string = &quot;str&quot;; //明示的string type let b = &quot;str&quot;; //タイプ推論によるstring type const c: string = &quot;str&quot;; //明示的string type const d = &quot;str&quot;; //タイプ推論によるLiteral type 5. Type Assertion とある変数を参照する時、タイプを明示的に絞ること type castingとは違い、データを変換したりしない とある変数を、指定タイプであることを前提に使うという宣言 もし使う場合があるなら、宣言に対しての信頼性が大事 使い方 someVar as TYPE &lt;TYPE&gt;someVar (jsxと紛らわしいので、非推奨) 12345// 主に曖昧なタイプから絞るときに使う。// 曖昧なタイプである時点で、ベストプラクティスではないので、参考までに見ることslet someVar: any = \"some string\";let strLength: number =(someVar as string).length; 6. Type Alias特定のタイプに別称をつけて使うことができる。あくまで、作られたタイプの参照を持つだけで、タイプを作ることではない。 1234567//alias to union typelet varA: string | number = 0;varA = \"A\";type StringOrNumber = string | number;let varB = 0;varB = \"B\"; 7. Interface実装を持たず、ステート（プロパティ）とビヘイビアの形式の定義のみを記述した抽象データタイプ。 インタフェースの抽象というのは、インスタンス化観点から抽象的であり具体を持たいないため、単体では実態を持てないという意味を内包している。 継承するクラスたちに対してのプロトコル（約束）の役目を果たす。 interface basics123456789101112131415161718//interfaceinterface Person { name: string; //--optional type age?: number; //-- function interface say(): string;}const person:Person = { name: \"Mark\", age: 34, say: (): string { return `hello. name=${this.name}`; }} interface - indexable typeindexのタイプとしては、stringか、numberを指定可能 12345678910interface Person { //--indexable type (number or string) [index: string]: string;}const person:Person = { name: \"Mark\"}person.age = \"34\";person[\"age\"] = \"34\";//person.age = 34; //index type error 123456789interface NumIndex { //--indexable type (number or string) [index: number]: object;}const queue:NumIndex = {}queue[0] = new Object();queue[1] = new Object();//queue[\"abc\"] = new Object(); //index type error//queue.abc = new Object(); //index type error class implements interface1234567891011121314151617181920interface IPerson { name: string; age?: number; say(): void;}class Person implements IPerson { name: string; constructor(name: string) { this.name = name; } say(): void { console.log(`hello. myname is ${this.name}.`); }}const person = new Person(\"Mark\");person.say(); interface extends interface12345678intrface Person { name: string; age: number;}interface SalaryMan extends Person { job: string;} function with interface123456789interface funcPerson { (name: string, age?: number): void;}const sayPerson: funcPerson = function (name: string) { console.log(`hello. myname is ${name}.`);}sayPerson(\"Mark\"); 8. Classオブジェクトの初期ステート（プロパティ）とビヘイビアを記述したテンプレートであり、User Defined Data Type. class basics12345678910111213141516171819class Person { protected _name: string = null; private _age: number = null; set _age;}class SalaryMan extends Person { private _job: string = null; constructor(name: string) { super(); this.name = name; }}const man: SalaryMan = new SalaryMan(\"Mark\"); Abstract class123456789101112abstract class APerson { protected _name: string = \"NoName\"; abstract setName(name: string): void;}class Person extends APerson { setName(name: string): void { this._name = name; }}const person = new Person(); readonly keyword &amp; static keyword &amp; private constructor※ typescriptでは、anti-partternだという意見もあり 1234567891011121314151617181920212223242526272829303132333435class Logger { private static singletonInstance: Logger; public readonly initTime: number; private constructor(){ this.initTime = new Date().getTime(); } public static getLogger = ():Logger =&gt; { if (Logger.singletonInstance === undefined) { Logger.singletonInstance = new Logger(); } return Logger.singletonInstance; } logInfo = (msg: string):void =&gt; { console.log(`logger-${this.initTime} : ${msg}`); }}Logger.getLogger().logInfo(\"first log\");setTimeout( (): void =&gt; { Logger.getLogger().logInfo(\"after 2sec log\"); }, 2000);//Logger.getLogger().initTIme = 5; //error because readonly property//--output//logger-1590906992695 : first log//logger-1590906992695 : after 2sec log 9. Genericパラメータのデータタイプを、インスタンス化の後で明示するプログラミング手法（to-be-specified-later）入力・出力のデータタイプを、任意のタイプに抽象化宣言する。タイプチェックは、ランタイムの前にコンパイラでしてくれるが、内部動作メカニズムとしては、実際にどういうデータタイプで入力・出力されるかは、インスタンス化後、実際に呼び出されるときに確定される。 Generic basics1234567function doPingPong&lt;T&gt;(message: T): T { return message;}console.log(doPingPong&lt;string&gt;(\"text\"));console.log(doPingPong&lt;number&gt;(10));console.log(doPingPong&lt;object&gt;({key: \"value\"})); Generic with class1234567891011121314151617181920class Code&lt;T extends string | number, O&gt; { private _code: T; private _data: O; constructor(code: T, data: O) { this._code = code; this._data = data; } getCode = (): T =&gt; { return this._code; } getData = (): O =&gt; { return this._data; }}const abc = new Code&lt;string,string&gt;(\"ABC\", \"data\");const oneTwoThree = new Code&lt;number, object&gt;(123, {}); 10. keyof -Lookup Types-keyof basics Indexed Type Lookup Query 演算子 オブジェクトで、アクセスが許容されているプロパティのインデックスをLiteral Typeとして算出する。 Genericと一緒に使うと有用 12345678910111213//-- indexed type query from Interfaceinterface IObj { keyA: number; keyB: number; }type restrictedAsKeysOfInterface = keyof IObj;let v1: restrictedAsKeysOfInterface = \"keyA\"; //same &gt;&gt; let v1: \"keyA\" | \"keyB\" = \"keyA\";// let v2: restrictedAsKeysOfInterface = \"key?\"; // error//-- indexed type query from Object(typeof)const obj = {keyA : 0, keyB : 1};type restrictedAsKeysFromObject = keyof typeof obj; //same &gt;&gt; let v1: \"keyA\" | \"keyB\" = \"keyA\";// let v2: restrictedAsKeysOfInterface = \"key?\"; // error Generic with keyof ランタイム前に、間違ったプロパティアクセスなどが検出できる。 1234567891011121314151617function getProperty&lt;T, K extends keyof T&gt;(obj:T, key:K) { return obj[key];}interface Person { name: string; age: number;}const person: Person = { name: \"Mark\", age: 35}getProperty(person, \"name\");getProperty(person, \"age\");//getProperty(person, \"unknown\"); //unasignable type error 11. Iterator今までの巡回Array巡回12345678// es3for (var i = 0; i &lt; array.length; i++)// es5array.forEach() //breakができないので、anti pattern// es6for (const item of array) // arrayのみ使える Object巡回1234567891011// -- for in// 推奨されない。理由は以下// - hello worldobject巡回時に使う。(arrayには柄はないはず)// - indexがnumberじゃなくstringで出る// - 配列内のプロパティも意図とは違って巡回できる可能性がある// - prototype chainのプロパティを巡回できる可能性もある// - 巡回の順序を保証しない// for ofが推奨される。// -- objectを巡回するときには、for ofで以下のように使うことも可能for (const prop of Object.keys(obj)) example12345678910111213141516171819202122232425262728293031323334const array = ['first', 'second'];const obj = { name: 'Mark', age: 35};// use for..of on Arrayfor (const item of array) { console.log(typeof item + ', ' + item);}// use for..in on Array// item type is string. value is numeric stringfor (const item in array) { console.log(typeof item + ', ' + item);}// use for..of on Object =&gt; Error/*for (const item of obj) { console.log(typeof item + ', ' + item);}*/// use for..in on Objectfor (const item in obj) { console.log(typeof item + ', ' + item);}// use for..on using keys on Objectfor (const item of Object.keys(obj)) { console.log(typeof item + ', ' + item);} Symbol.iterator概要 プロパティ。巡回関数が具現されているとiterableなタイプになる。 Array, Map, Set, String, Int32Array, Uint32Arrayなどには、内蔵された具現体があるので、iterableなタイプである。 ただのobjectはiterableではない。 Iteratorを使い、IterableなオブジェクトのSymbol.iterator関数を呼び出す。 target es3 or es5 Arrayのみfor..ofを使える オブジェクトに使うとエラー es6 SYmbol.iteratorを具現すると、どんなオブジェクトにもfor..ofを使える typescriptのIteratorインタフェース12345678910111213141516171819// lib.es6.d.tsinterface IteratorResult&lt;T&gt; { done: boolean; value: T;}interface Iterator&lt;T&gt; { next(value?: any): IteratorResult&lt;T&gt;; return?(value?: any): IteratorResult&lt;T&gt;; throw?(e?: any): IteratorResult&lt;T&gt;;}interface Iterable&lt;T&gt; { [Symbol.iterator](): Iterator&lt;T&gt;;}interface IterableIterator&lt;T&gt; extends Iterator&lt;T&gt; { [Symbol.iterator](): IterableIterator&lt;T&gt;;} Iterable具現12345678910111213141516171819202122232425class CustomIterable implements Iterable&lt;string&gt; { private _array: Array&lt;string&gt; = ['first', 'second']; [Symbol.iterator]() { var nextIndex = 0; return { next: () =&gt; { return { value: this._array[nextIndex++], done: nextIndex &gt; this._array.length } } } }}const cIterable = new CustomIterable();for (const item of cIterable) { console.log(item);}//[LOG]: first //[LOG]: second 12. Decorator Decoratorを使うためには、config設定必要 各Decoratorパターンに対するシグニチャーを見ておくこと Setting12345678$ mkdir ts-decorator$ cd ts-decorator$ yarn init -y$ yarn add typescript -D# setting tsconfig$ node_modules/.bin/tsc --init-- tsconfig.jsonのexperimentalDecoratorsをtrueに設定 Class Decorator Example123456789101112131415161718192021function hello(constructFn: Function) { console.log(constructFn);}function helloFactory(show: boolean) { if (show) { return hello; } else { return null; }}@helloFactory(false)class Person {}@helloFactory(true)class Person2 {}//--output//$ node dist/Test.js //[Function: Person2] 12345678910111213141516171819202122232425262728function editable(canBeEdit: boolean) { return function(target: any, propName: string, description: PropertyDescriptor) { console.log(canBeEdit); console.log(target); console.log(propName); console.log(description); description.writable = canBeEdit; }}class Person { constructor() { console.log('new Person()'); } @editable(true) hello() { console.log('hello'); }}const person = new Person();person.hello();person.hello = function() { console.log('world');}person.hello(); 12345678910111213141516171819function addHello(constructorFn: Function) { constructorFn.prototype.hello = function() { console.log('hello'); }}@addHelloclass Person { constructor() { console.log('new Person()'); }}const person = new Person();(&lt;any&gt;person).hello(); //使い方に短所があるが、ライブラリやフレームワークなどの開発にはいいパターンかも//--output//$ node dist/Test.js //hello Method Decorator Example1234567891011121314151617181920212223242526272829303132333435363738394041424344454647function editable(canBeEdit: boolean) { return function(target: any, propName: string, description: PropertyDescriptor) { console.log(canBeEdit); console.log(target); console.log(propName); console.log(description); //descriptorのwritable属性がランタイム時に変わる description.writable = canBeEdit; }}class Person { constructor() { console.log('new Person()'); } @editable(true) hello() { console.log('hello'); }}const person = new Person();person.hello();// editableをtrueにしていたので、上書きされる。// ※ editableをfalseにした場合は上書きされない。person.hello = function() { console.log('world');}person.hello();// --output// true// Person {}// hello// {// value: [Function: hello],// writable: true,// enumerable: false,// configurable: true// }// new Person()// hello// world // ※上書きされた関数の結果。editableがfalseなら、結果は「hello」 Property Decorator1234567891011121314151617181920212223242526function writable(canBeWrite: boolean) { return function(target: any, propName: string): any { console.log(canBeWrite); console.log(target); console.log(propName); return { writable: canBeWrite } }}class Person { @writable(false) name: string = 'Mark'; constructor() { console.log('new Person()'); }}const person = new Person();console.log(person.name);// --output//TypeError: Cannot assign to read only property 'name' of object '#&lt;Person&gt;'//※ writable(true)にすると、エラーなく動作する Parameter Decorator123456789101112131415161718192021222324252627function printInfo(target: any, methodName: string, paramIndex: number) { console.log(target); console.log(methodName); console.log(paramIndex);}class Person { private _name: string; private _age: number; constructor(name: string, @printInfo age: number) { this._name = name; this._age = age; } hello(@printInfo message: string) { console.log(message); }}//-- output// Person { hello: [Function] }// hello// 0// [Function: Person]// undefined// 1 13. Type Inference タイプを明示しなかった場合のタイプ推論規則 letは、基本データ・タイプで推論 constはリタラル・タイプで推論 objectタイプを使わないと、プロパティはletと同じように推論 const person = {name:’Mark’, age: 35} person =&gt; {name: string; age: number;}で推論される 大体は推論自体は簡単 単純な変数 structuring, destructuring array, 関数のリターンに対しては推論が難しい場合が多い ArrayのType Inference123456789101112131415161718192021const array1 = []; // any[]const array2 = ['a', 'b', 'c']; // string[]const array3 = ['a', 1, false]; // (string|number|boolean)[] ※ inferenced as union typeclass Animal { name: string;}class Dog extends Animal { dog: string;}class Cat extends Animal { cat: string;}const array4 = [new Dog(), new Cat()];// (Dog | Cat)[] returnのType Inference123456789function hello(message: string | number) { if (message === 'world') { return 'world'; } else { return 0; }}// return type inference =&gt; ('world' | 0)// literal union Union TypeとType Guard123456789101112131415161718192021222324252627interface Person { name: string; age: number;}interface Car { brand: string; wheel: number;}//Type Guard//tell this is Person when returnfunction isPerson(arg: any): arg is Person { return arg.name !== undefined;}function hello(arg: Person | Car) { if (isPerson(arg)) { //this is Person. not Car. console.log(arg.name); // console.log(arg.brand); //error } else { //this is Not Person. so this is Car. // console.log(arg.name); //error console.log(arg.brand); }}","link":"/2020/07/26/Typescript%E6%9B%B8%E3%81%8D%E6%96%B9%E3%81%AE%E9%80%9F%E6%88%90%E3%81%BE%E3%81%A8%E3%82%81/"},{"title":"PHP・GCの話-2話)変数の管理情報、zval containerとreference count","text":"前書き すべての記事は、自分の勉強目的と主観の整理を含めています。あくまで参考レベルで活用してください。もし誤った情報などがあればご意見をいただけるととっても嬉しいです。 内容では、省略するか曖昧な説明で、わかりづらいところもあると思います。そこは、連絡いただければ補足などを追加するので、ぜひ負担なくご連絡ください。 本文での「GC」は、「Garbage Collection, Garbage Collector」の意味しており、略語として使われています。 この記事は、連載を前提に構成されています。 ※ 連載目録 PHP・GCの話-1話)なぜGarbageCollection? メモリとGCを意識する PHP・GCの話-2話)変数の管理情報、zval containerとreference count （←現在の記事） PHP・GCの話-3話)変数データのメモリからの消滅 ⇨ 準備中 PHP・GCの話-4話)MemoryLeakと解除できない変数データ ⇨ 準備中 PHP・GCの話-5話)GC登場。GC発生条件とroot buffer ⇨ 準備中 PHP・GCの話-6話)管理対象の巡回・削除。Garbage Collection Cycle ⇨ 準備中 PHP・GCの話-7話)GC関連機能紹介(GC Statistics, Weak Reference Type)(END) ⇨ 準備中 ※ 連載で使うサンプルコード Sample Code Link on Github ● ExampleGc.php : 2話から6話までの内容で使うサンプルコードです。● ExampleWeakReference : 7話のWeakReferenceの内容で使うサンプルコードです。 今回の話今回は、PHPの変数に関して、以下のものを話そうと思うます。 変数宣言とzval container zvalのrefcount, is_ref属性、debug方法 zval debug実戦（サンプルコード） Summary 1. 変数宣言とzval containerPHPではzval container 構造体という特別な属性の集合体を定義しています。一言でいうと、変数の実データと参照情報を持つ属性の集合体と言えます。 もう少し詳しく説明すると、 1$str = 'str'; phpで変数を宣言し使うと、PHPは実行時にいろんな作業を行うことになります。そのうち一つとして、PHPは変数の初期化と共に、変数ごとにzvalという特別な属性の集合体を作り、該当変数と結びつけます。 以下は、変数とzval containerの関係を抽象化し表した図になります。 ※ 絵の凡例説明Code Section : 実際のPHPコードの状態を表します。Variable Scope : 変数の有効範囲内の変数シンボルの状態を表します。Heap Space : メモリ内の実際の値の積み重ね(Heap)空間を意味します。 PHPにおいて、すべての変数データは、zval Containerと呼ばれるコンテナーとマッピングされます(以降zvalと呼びます。)。 絵のコードのように、変数をセットすると、※1 変数シンボル(以下、便宜上変数と呼びます)が、現在の変数の有効※2 スコープに生成されます。同時に、zvalというものが作られ、変数はzvalを示すことになり、zval内のvalue属性として実際の値を持つ構造になっています。※3 このzvalの役目は、変数を管理するために必要な情報を保持させることにあり、valueとtype以外にrefcountとis_refという属性を各変数ごとに保持します。 以下は、phpのソースコードからの引用したコードです(Cの構造体)。ただし、zvalの構造に関しては、PHPバージョンとデータタイプによって異なる可能性もありますので、心に留めた上でご参考ください。 123456struct _zval_struct { zvalue_value value; zend_uchar type; zend_uchar is_ref; zend_ushort refcount; }; 2. zvalのrefcount, is_ref属性、debug方法zvalの属性の中で、変数データの参照状態を表す属性は、以下の二つがあります。 refcount (★重要) integerの値を持ちます。変数が示している「※4 実際の値が参照されているカウント」を意味します。変数自分自身だけだと１，外でも参照されていると2以上になります。 GCのメカニズムの核心になる属性 is_ref booleanの値を持ちます。変数が※5 reference setである場合、1(true)になります。 ※ 当記事では対象外、詳しく扱わない 加えて、zvalの属性はphpでdebugが可能です。phpでは、以下の関数を提供しています。 1debug_zval_dump ( mixed $variable [, mixed $... ] ) : void xdebug拡張では、以下の関数を提供しています。 1xdebug_debug_zval( string ...$varname ) : void 本記事では、xdebug_debug_zvalを利用します。 3. zval debug実戦（サンプルコード付き）では、いろんなタイプの変数のzvalを直接debugしてみましょう。Value Copy &amp; Reference Copyに加えて、refcountの変化をよくみていただけると良いと思います。 サンプルコードをご参考になる方は、以下のURLで開かれるラインから確認いただけます。- GITHUB SOURCE CODE LINK - PHPでサポートしているデータタイプの詳細な説明は省略します。 もしまだ詳しくない方は、以下のPHP Language Reference→Typesを参考すると良いと思います。https://www.php.net/manual/en/language.types.php 1) stringのzval属性 (Scalar TypeのValue Copy) 123456789$str = \"sometext\";$toBeCopiedAsString = $str;xdebug_debug_zval('str');xdebug_debug_zval('toBeCopiedAsString');/* --OUTPUTstr: (refcount=1, is_ref=0)='sometext'toBeCopiedAsString: (refcount=1, is_ref=0)='sometext'*/ 基本的な構造になります。stringのようなScalar Valueの変数を他の変数にアサインする時には、基本Vaule Copyで動作します。※6なので、PIC-2-1のように実際の値のsometextは、メモリ空間に2個存在することになります。そして、$strと$toBeCopiedAsStringの変数は、各自違うメモリ内の値を示すことになるので、refcount=1になります。 2) objectのzval属性 (Compound TypeのReference Copy) 123456789101112131415161718192021222324Log::debug(null, ['event' =&gt; 'set', 'msg' =&gt; 'reference copy of object']);$object = new \\stdClass;$toBeRefCopyFromObject = $object;$toBeUnset = $object;xdebug_debug_zval('object');xdebug_debug_zval('toBeRefCopyFromObject');xdebug_debug_zval('toBeUnset');Log::debug(null, ['event' =&gt; 'unset', 'msg' =&gt; 'reference copy of object']);unset($toBeUnset);xdebug_debug_zval('object');xdebug_debug_zval('toBeRefCopyFromObject');xdebug_debug_zval('toBeUnset');/* --OUTPUT[2020-08-12 13:21:02] local.DEBUG: {\"event\":\"set\",\"msg\":\"reference copy of object\"}object: (refcount=3, is_ref=0)=class stdClass { }toBeRefCopyFromObject: (refcount=3, is_ref=0)=class stdClass { }toBeUnset: (refcount=3, is_ref=0)=class stdClass { }[2020-08-12 13:21:02] local.DEBUG: {\"event\":\"unset\",\"msg\":\"reference copy of object\"}object: (refcount=2, is_ref=0)=class stdClass { }toBeRefCopyFromObject: (refcount=2, is_ref=0)=class stdClass { }toBeUnset: no such symbol*/ 今回は、classをnewしたobjectを示す変数になります。object変数は、他の変数にアサインするときには、基本Reference Copyで動作します。なのでValue Copyとは違い、絵2のように実際の値であるobjectは、メモリ空間には1個存在することになります。そして、$objectと$toBeRefCopyFromObject、$toBeUnsetの変数は、同じメモリ内の値を示すことになるので、もとの値のzvalのrefcountが1ずつ増加し、refcount=3になります。 その後、$toBeUnsetを※7 unsetし、シンボルのレファレンスを解除します。そうすると、もとの値を参照する変数が一つなくなったので、refcountは１減少します。 なので、最終的にrefcount=2になります。 3) arrayのzval属性 (Compound TypeのReference Copy &amp; Value Copy) 1234567891011121314151617181920Log::debug(null, ['event' =&gt; 'set', 'msg' =&gt; 'reference copy of array']);$array = array_fill(0,2,0);$toBeRefFromArray = $array;xdebug_debug_zval('array');xdebug_debug_zval('toBeRefFromArray');Log::debug(null, ['event' =&gt; 'set', 'msg' =&gt; 'changing value copy of array']);$array[1] = 1;xdebug_debug_zval('array');xdebug_debug_zval('toBeRefFromArray');/* --OUTPUT[2020-08-12 13:00:23] local.DEBUG: {\"event\":\"set\",\"msg\":\"reference copy of array\"}array: (refcount=2, is_ref=0)=array (0 =&gt; (refcount=0, is_ref=0)=0, 1 =&gt; (refcount=0, is_ref=0)=0)toBeRefFromArray: (refcount=2, is_ref=0)=array (0 =&gt; (refcount=0, is_ref=0)=0, 1 =&gt; (refcount=0, is_ref=0)=0)[2020-08-12 13:00:23] local.DEBUG: {\"event\":\"set\",\"msg\":\"changing value copy of array\"}array: (refcount=1, is_ref=0)=array (0 =&gt; (refcount=0, is_ref=0)=0, 1 =&gt; (refcount=0, is_ref=0)=1)toBeRefFromArray: (refcount=1, is_ref=0)=array (0 =&gt; (refcount=0, is_ref=0)=0, 1 =&gt; (refcount=0, is_ref=0)=0)*/ 最後に、arrayを示す変数になります。arrayは、他の変数にアサインするときには、基本Reference Copyで動作します。しかしarrayは、配列内の値を変えると、PHP内部的にValue Copyを行い、新しいarrayをメモリ空間に生成する特性があります。 なので、最初は、refcount=2で、同じメモリ空間の値を示していたものが、値を変えた瞬間、お互いに違うarrayを示すことになりrefcount=1になっています。arrayの内容も$arrayは値を変更下(0,1)で、$toBeRefFromArrayはもともとの値である(0,0)になっています。 4. Summary今回で、最低限に覚えて頂くと良い内容は、以下になります。 変数を定義すると、実際のデータと共に、「変数シンボル」と「zval」が作られる。 zvalは、変数を管理するための情報を持っている。 (重要) zval属性のrefcountは、Reference Copyが起きると１増加し、変数が無効になると１減少する。※8 後書きここまで、変数宣言とzval属性、変数の参照とその変化に関して見ました。メモリ観点において、変数を宣言した時に何が起きるのかという観点は時々大事な観点になると思います。 そして、開発言語ごとに、変数の初期化と管理メカニズムは共通するところもあれば、違うところもあるので、他の言語と比較してみるのも面白いでしょう。 今回は、次回の話の「変数データの消滅条件」を扱うことになりますが、前提としては参照カウント(phpではrefcount)の理解が必要になっているので、zvalとReference Copyに関して説明する話を用意いたしました。 では、次回も頑張って行きます。 ※注釈 ※1▶ 変数シンボル $obj=new stdClass;にした場合、$objが変数シンボル、new stdClassで生成されたobject(instance)が、実際の値になります。$objの部分は、「変数のシンボル」が正確な名称かもですが、以降、便宜上変数と呼ぶようにします。 ※2▶ スコープ※ 本連載記事でのスコープの意味は、主に「ローカルスコープ、スコープスタック、全域スコープ」を全て含めています。 スコープとは、いろんな言語で「変数の有効範囲」して定義します。PHPでは「シンボルテーブル」という概念が正しいですが、本記事では理解の便宜上スコープと呼ぶようにします。もし、詳しく見たい方は、PHPのデータ構造メカニズムを探してみると、シンボルテーブルに関する説明も出てくるのでおすすめです。 ※3▶ zval内のvalue属性として実際の値を持つ構造になっています。 ここでは、zvalのみ表記していますが、色々省略されています。実は、symbol tableを始め、zval struct, zval value structなど色々あり、データタイプによって、また色々連携された構造を持つことになります。詳しく見たい方は、PHPのデータ構造メカニズムを探してみるとzval struct, zval value structなどを詳細に解説した資料があるのでおすすめします。php5と7では、またメカニズムが違ってくるので、難しいですね(泣) ※4▶ 実際の値 ここでの実際の値と言うのは、Literal値はもちろん、array, objectなどで実際にメモリに保存されている値, resourceの実際資源などの示しています。 ※5▶ reference set reference setとは、「&amp;」演算子を使いレファレンスとして定義された変数を意味します(assigning by reference)。reference setとして定義する場合、新しく定義した変数と被参照変数両方is_ref=1になります。phpには、レファレンスタイプを扱う中で、Reference Copyと、Reference Setのタイプがありますが、その定義と違いに関しては、今回のGCのテーマとは少し範囲が違うので省略させていただきます。もしリクエストがある場合は、別記事として上げていただきますので、ご連絡ください。 ※6▶ Scalar Valueの変数を他の変数にアサインする時には、基本Vaule Copyで動作します。 補足として、Scalar Typeの一つであるintegerは、また特殊な動作を行いますので、気になる方はデバッグしてみてください。（最小は定数として動作し、&amp;演算子とかでReference Setにすると、参照変数に変わります。自分もすべてのパターンは把握していないので、説明するのは少し難しいですね。笑） ※7▶ unset unset()は、レファレンスを持つ変数シンボルを変数有効範囲から解除する関数です。実際のメモリの値を消す関数では無いことに注意しましょう。unsetする時に、参照するところが0(つまりrefcount=0)の場合は、内部的にすぐメモリから実際の値も解除されますが、refcountが１以上だと、その値はメモリから削除されずずっと残っている状態になります。このメカニズムに関しては、後ほど扱う予定なので、まずはと止めて置くだけで大丈夫です。 ※8▶ zval属性のrefcountは、Reference Copyが起きると１増加し、変数が無効になると１減少する。 補足ですが、Reference Setが起きる場合もzvalのrefcount+1で、is_refが1に変化します。Reference Setに対するzval属性の変化も理解しておけば良いのですが、GCの理解においては必須ではありません。","link":"/2020/08/13/PHP%E3%83%BBGC%E3%81%AE%E8%A9%B1-2%E8%A9%B1-%E5%A4%89%E6%95%B0%E3%81%AE%E7%AE%A1%E7%90%86%E6%83%85%E5%A0%B1%E3%80%81zval-container%E3%81%A8reference-count/"},{"title":"PHP・GCの話-4話)MemoryLeakと解除できない変数データ","text":"前書き すべての記事は、自分の勉強目的と主観の整理を含めています。あくまで参考レベルで活用してください。もし誤った情報などがあればご意見をいただけるととっても嬉しいです。 内容では、省略するか曖昧な説明で、わかりづらいところもあると思います。そこは、連絡いただければ補足などを追加するので、ぜひ負担なくご連絡ください。 本文での「GC」は、「Garbage Collection, Garbage Collector」の意味しており、略語として使われています。 この記事は、連載を前提に構成されています。 ※ 連載目録 PHP・GCの話-1話)なぜGarbageCollection? メモリとGCを意識する PHP・GCの話-2話)変数の管理情報、zval containerとreference count PHP・GCの話-3話)変数データのメモリからの消滅 PHP・GCの話-4話)MemoryLeakと解除できない変数データ（←現在の記事） PHP・GCの話-5話)GC登場。GC発生条件とroot buffer ⇨ 準備中 PHP・GCの話-6話)管理対象の巡回・削除。Garbage Collection Cycle ⇨ 準備中 PHP・GCの話-7話)GC関連機能紹介(GC Statistics, Weak Reference Type)(END) ⇨ 準備中 ※ 連載で使うサンプルコード Sample Code Link on Github ● ExampleGc.php : 2話から6話までの内容で使うサンプルコードです。● ExampleWeakReference : 7話のWeakReferenceの内容で使うサンプルコードです。 本連載記事は、基本的にこのサンプルコードをベースに説明をしています。サンプルコードは、必ず見る必要も実行してみる必要もありません。各話ごとに、コードを分解して動作原理と結果を解説しますので、基本記事の内容で足りるように心がけます。あくまで、全体コードをみたい、手元で回してみたい、修正して回してみたいという方向けです。 今回の話今回は、以下のものを話そうと思うます。 Memory Leakとは？ 解除できない変数データの例 (循環参照) Summary 今回からは、本格的にサンプルコードを引用しながら、見ていきますので、以下のリンクのコードを一緒に参考にしながら見ると良いと思います。 1. Memory Leakとは？シンプルに言うと、 もう使えない変数データが、メモリを専有し続ける現象 ですね。これを「ゴミ・Garbage」と表現したりもします。 もうちょっと詳しく説いて行くために、Memory Leakの定義をwikiから引用すると、 https://en.wikipedia.org/wiki/Memory_leak#cite_note-1 ① In computer science, a memory leak is a type of resource leak that occurs when a computer program incorrectly manages memory allocations in such a way that memory which is no longer needed is not released.② A memory leak may also happen when an object is stored in memory but cannot be accessed by the running code. 少し意訳すると ① コンピューター工学において、Memory Leakとは、プログラムで、もう使わないのに解除されないような、間違ったメモリ空間の割当により起きる、有限な資源の無駄遣いの現象です。② 一例として、memory leakは、メモリに保存はされているものの、実行コード上ではこれ以上サクセスされないオブジェクトにより起きることもありえます。 ですね。 それ以外で一番多い事例は、ネットワークコネクションやグラフィックなどのresourceタイプの解除を忘れることだと思います。※1 ②に対するMemory Leakの一つの例が、今から見ていく「循環参照」です。引き続き、②の事例の「循環参照」に関して詳しく見ていきます。 2. 解除できない変数データの例ここでの「解除できない」というのは、 プログラマーの意図的には、すでに解除しており、これ以上使われるはずのない変数の元データがメモリ上にの残り続けること を意味します。 簡単な例えとしては、オブジェクト同士の「循環参照」があります。簡単なコードで紹介すると以下のコードで再現できます。 12345678910$a = new \\stdClass;$b = new \\stdClass;//循環参照$a-&gt;node = $b;$b-&gt;node = $a;//これ以上使われないはずなので、このケースは、メモリからデータは消滅しないunset($a);unset($b); これがなぜ、問題になるのかを、サンプルコードと実行結果で解説します。 1) サンプルコード例● クラス定義引用Sample Code Link on Github 12345678910111213141516171819202122232425abstract class Base{ private $dummyData; private $tag = null; private $nodes = array(); public function __construct($tag) { $this-&gt;tag = $tag; $this-&gt;dummyData = str_repeat('a', 20*1024*1024); //20M Byte size approximately } /** * add Reference as ChildNode */ public function addNode(object $obj) { $this-&gt;nodes[] = $obj; return $this; }}class AliveInScope extends Base {}class CircularReference extends Base {} ● コード引用Sample Code Link on Github 12345678910111213141516171819202122232425262728293031 private function doExampleGcBasic() {//...中略 Log::debug(null, ['event' =&gt; 'new', 'msg' =&gt; 'V']); $alive = new AliveInScope('V');//...中略 Log::debug(null, ['event' =&gt; 'new', 'msg' =&gt; 'A, B']); $circleA = new CircularReference('A'); $circleB = new CircularReference('B'); Log::debug(null, ['event' =&gt; 'set', 'msg' =&gt; '$alive`s reference to A']); $circleA-&gt;addNode($alive); Log::debug(null, ['event' =&gt; 'set', 'msg' =&gt; 'circluar reference on A B']); $circleA-&gt;addNode($circleB); $circleB-&gt;addNode($circleA); xdebug_debug_zval('alive'); xdebug_debug_zval('circleA'); xdebug_debug_zval('circleB'); $this-&gt;logMemUsage(); Log::debug(null, ['event' =&gt; 'unset', 'msg' =&gt; 'A, B']); unset($circleA); unset($circleB); xdebug_debug_zval('alive'); xdebug_debug_zval('circleA'); xdebug_debug_zval('circleB'); $this-&gt;logMemUsage();//...中略 ● 実行結果引用 1234567891011121314151617root@bc290870f5e9:/var/www/html/subdomain/laravel# ./artisan example:gc | cut -d &quot;$&quot; -f 1[2020-09-07 20:30:37] local.DEBUG: {&quot;event&quot;:&quot;new&quot;,&quot;msg&quot;:&quot;V&quot;}alive: (refcount=1, is_ref=0)=class App\\Console\\Commands\\AliveInScope { private [2020-09-07 20:30:37] local.DEBUG: {&quot;Memory Usage(Bytes)&quot;:&quot;37,060,552&quot;} [2020-09-07 20:30:37] local.DEBUG: {&quot;event&quot;:&quot;new&quot;,&quot;msg&quot;:&quot;A, B&quot;}[2020-09-07 20:30:37] local.DEBUG: {&quot;event&quot;:&quot;set&quot;,&quot;msg&quot;:&quot;[2020-09-07 20:30:37] local.DEBUG: {&quot;event&quot;:&quot;set&quot;,&quot;msg&quot;:&quot;circluar reference on A B&quot;}alive: (refcount=2, is_ref=0)=class App\\Console\\Commands\\AliveInScope { private circleA: (refcount=2, is_ref=0)=class App\\Console\\Commands\\CircularReference { private circleB: (refcount=2, is_ref=0)=class App\\Console\\Commands\\CircularReference { private [2020-09-07 20:30:37] local.DEBUG: {&quot;Memory Usage(Bytes)&quot;:&quot;79,015,032&quot;} [2020-09-07 20:30:37] local.DEBUG: {&quot;event&quot;:&quot;unset&quot;,&quot;msg&quot;:&quot;A, B&quot;}alive: (refcount=2, is_ref=0)=class App\\Console\\Commands\\AliveInScope { private circleA: no such symbolcircleB: no such symbol[2020-09-07 20:30:37] local.DEBUG: {&quot;Memory Usage(Bytes)&quot;:&quot;79,015,672&quot;} 2) コードと実行結果の解説123Log::debug(null, ['event' =&gt; 'set', 'msg' =&gt; 'circluar reference on A B']);$circleA-&gt;addNode($circleB);$circleB-&gt;addNode($circleA); 123[2020-09-07 20:30:37] local.DEBUG: {&quot;event&quot;:&quot;set&quot;,&quot;msg&quot;:&quot;circluar reference on A B&quot;}...中略[2020-09-07 20:30:37] local.DEBUG: {&quot;Memory Usage(Bytes)&quot;:&quot;79,015,032&quot;} ソスコード上の上記のポイントで、AとBは、お互いの内部でお互いを参照することになります。その後のメモリの使用量は「79,015,032」Bytesになっています。 123Log::debug(null, ['event' =&gt; 'unset', 'msg' =&gt; 'A, B']);unset($circleA);unset($circleB); 12345[2020-09-07 20:30:37] local.DEBUG: {&quot;event&quot;:&quot;unset&quot;,&quot;msg&quot;:&quot;A, B&quot;}alive: (refcount=2, is_ref=0)=class App\\Console\\Commands\\AliveInScope { private circleA: no such symbolcircleB: no such symbol[2020-09-07 20:30:37] local.DEBUG: {&quot;Memory Usage(Bytes)&quot;:&quot;79,015,672&quot;} unsetをして、A,Bは、これ以上使うこともできないのに、なぜかメモリの使用量は減っていません。つまり、使うこのもないのに、有限であるメモリ空間をずっと専有していることになります。 なぜ、メモリの使用量は減らずに、実のデータがずっと残り続けるのでしょう。 3) コードの実行時に起きる変数と参照カウントの変化解説(GIF)①循環参照変数の生成の段階の変化 上記のイメージの４番目のように、AとBは、$circleA, $circleBの参照以外に、各自の内部で、お互いを参照するようになります。だとしたら、$circleAと$circleBをunsetし、変数を無効にしたらどうなるのでしょう。 ②$circleAと$circleBをunsetした後の段階の変化 (絵が間違っている) 前回の「変数が消滅しない条件」は 「実際のデータの参照が一つ無効になる」時、参照カウント(refcount)が「1以上」であれば、データは消滅せずに残り続ける。 でした。 絵の2番めのように、$circleAと$circleBの変数を解除したことで、2つとも実のデータにアクセスできなくなりました。しかし、元のデータはお互いを参照しているので、参照カウントは2→1になりますが、その時の参照カウントが1以上であるため、「どこかで使われている」とシステムでは認識し、メモリから解除することはできなくなります。 なので、プログラマー的には、消滅してほしいデータであるにも関わらず、ずっとメモリに残り続けることになります。 まさに、Memory Leakとして話した、もう使えない変数データが、メモリを専有し続ける現象であり、ゴミ・Garbageですね。 だとしたら、このゴミ問題を解決するために、PHPではどういう機能を提供しているのでしょうか。 その一つが、次回に登場するGC・Garbage Collectionになります。そこは、次回に詳しく説明することになります。 3. Summary今回で、最低限に覚えて頂くと良い内容は以下になります。 Memory Leakとは、「もう使えない変数データが、メモリを専有し続ける現象」であり、「ゴミ」が残る現象 循環参照は、Memory Leakのわかりやすい例であり、GCが収集する対象としてのわかりやすい一例 このゴミ問題を解決するために、PHPではどういう機能の一つが、GC・Garbage Collection 後書き1話から今回まではGCの背景になる、変数の仕様・動作・消滅メカニズムなどを話してきました。次からは、本格的にGCのメカニズムに対して話していきます。 GCの発生条件や明示的に発生させる方法、GCが起きたら行われるメカニズムを解説していきます。この時に、zvalと参照カウントの理解と、変数の消滅基準、消滅せず残り続けるデータの理解が必要なので、それを意識した上で、ご覧頂けると嬉しいです。 説明とは不足なところか、分かりづらいところはあるかもですが、フードバック頂けると補足とか訂正いたしますので、宜しくお願いします。 ※注釈 ※1▶ resourceタイプの解除を忘れること 実のところ最近は、resourceタイプに対しても使われなくなったら自動解除してくれたりします。しかし例外な場合も無いわけでは無いのでresourceタイプ（または違う言語での類似タイプ）の解除は意識しておくと良いです。","link":"/2020/09/08/PHP%E3%83%BBGC%E3%81%AE%E8%A9%B1-4%E8%A9%B1-MemoryLeak%E3%81%A8%E8%A7%A3%E9%99%A4%E3%81%A7%E3%81%8D%E3%81%AA%E3%81%84%E5%A4%89%E6%95%B0%E3%83%87%E3%83%BC%E3%82%BF/"}],"tags":[{"name":"engineer","slug":"engineer","link":"/tags/engineer/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"shell","slug":"shell","link":"/tags/shell/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"git pages","slug":"git-pages","link":"/tags/git-pages/"},{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"docker-compose","slug":"docker-compose","link":"/tags/docker-compose/"},{"name":"lamp","slug":"lamp","link":"/tags/lamp/"},{"name":"html","slug":"html","link":"/tags/html/"},{"name":"vscode","slug":"vscode","link":"/tags/vscode/"},{"name":"php","slug":"php","link":"/tags/php/"},{"name":"GC","slug":"GC","link":"/tags/GC/"},{"name":"Garbage Collection","slug":"Garbage-Collection","link":"/tags/Garbage-Collection/"},{"name":"メモリ管理","slug":"メモリ管理","link":"/tags/%E3%83%A1%E3%83%A2%E3%83%AA%E7%AE%A1%E7%90%86/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"typescript","slug":"typescript","link":"/tags/typescript/"}],"categories":[{"name":"engineer life","slug":"engineer-life","link":"/categories/engineer-life/"},{"name":"docker","slug":"docker","link":"/categories/docker/"},{"name":"tools","slug":"tools","link":"/categories/tools/"},{"name":"front-end-markup","slug":"front-end-markup","link":"/categories/front-end-markup/"},{"name":"php","slug":"php","link":"/categories/php/"},{"name":"javascript","slug":"javascript","link":"/categories/javascript/"},{"name":"core features","slug":"php/core-features","link":"/categories/php/core-features/"},{"name":"typescript","slug":"javascript/typescript","link":"/categories/javascript/typescript/"}]}